package com.tw ter.fr gate.pushserv ce.conf g

 mport com.tw ter.abuse.detect on.scor ng.thr ftscala.T etScor ngRequest
 mport com.tw ter.abuse.detect on.scor ng.thr ftscala.T etScor ngResponse
 mport com.tw ter.aud ence_rewards.thr ftscala.HasSuperFollow ngRelat onsh pRequest
 mport com.tw ter.b ject on.scrooge.B naryScalaCodec
 mport com.tw ter.b ject on.scrooge.CompactScalaCodec
 mport com.tw ter.channels.common.thr ftscala.Ap L st
 mport com.tw ter.channels.common.thr ftscala.Ap L stD splayLocat on
 mport com.tw ter.channels.common.thr ftscala.Ap L stV ew
 mport com.tw ter.content_m xer.thr ftscala.ContentM xer
 mport com.tw ter.convers ons.Durat onOps._
 mport com.tw ter.cortex.deepb rd.thr ftjava.Deepb rdPred ct onServ ce
 mport com.tw ter.cr_m xer.thr ftscala.CrM xer
 mport com.tw ter.datatools.ent yserv ce.ent  es.sports.thr ftscala.BaseballGa L veUpdate
 mport com.tw ter.datatools.ent yserv ce.ent  es.sports.thr ftscala.BasketballGa L veUpdate
 mport com.tw ter.datatools.ent yserv ce.ent  es.sports.thr ftscala.Cr cketMatchL veUpdate
 mport com.tw ter.datatools.ent yserv ce.ent  es.sports.thr ftscala.NflFootballGa L veUpdate
 mport com.tw ter.datatools.ent yserv ce.ent  es.sports.thr ftscala.SoccerMatchL veUpdate
 mport com.tw ter.d scovery.common.conf gap .Conf gParamsBu lder
 mport com.tw ter.d scovery.common.conf gap .FeatureContextBu lder
 mport com.tw ter.d scovery.common.env ron nt.{Env ron nt => Not fEnv ron nt}
 mport com.tw ter.esc rb rd.common.thr ftscala.Doma ns
 mport com.tw ter.esc rb rd.common.thr ftscala.Qual f ed d
 mport com.tw ter.esc rb rd. tadata.thr ftscala.Ent y gadata
 mport com.tw ter.esc rb rd. tadata.thr ftscala. tadataServ ce
 mport com.tw ter.esc rb rd.ut l. tadatast ch. tadataSt chCl ent
 mport com.tw ter.esc rb rd.ut l.uttcl ent
 mport com.tw ter.esc rb rd.ut l.uttcl ent.Cac Conf gV2
 mport com.tw ter.esc rb rd.ut l.uttcl ent.Cac dUttCl entV2
 mport com.tw ter.esc rb rd.utt.strato.thr ftscala.Env ron nt
 mport com.tw ter.eventbus.cl ent.EventBusPubl s rBu lder
 mport com.tw ter.events.recos.thr ftscala.EventsRecosServ ce
 mport com.tw ter.explore_ranker.thr ftscala.ExploreRanker
 mport com.tw ter.featuresw c s.v2.FeatureSw c s
 mport com.tw ter.f nagle. mcac d
 mport com.tw ter.f nagle.Thr ftMux
 mport com.tw ter.f nagle.cl ent.BackupRequestF lter
 mport com.tw ter.f nagle.cl ent.Cl entReg stry
 mport com.tw ter.f nagle.loadbalancer.Balancers
 mport com.tw ter.f nagle. mcac d.Cl ent
 mport com.tw ter.f nagle.mtls.aut nt cat on.Serv ce dent f er
 mport com.tw ter.f nagle.mtls.cl ent.MtlsStackCl ent._
 mport com.tw ter.f nagle.mux.transport.Opportun st cTls
 mport com.tw ter.f nagle.serv ce.Retr es
 mport com.tw ter.f nagle.serv ce.RetryPol cy
 mport com.tw ter.f nagle.stats.StatsRece ver
 mport com.tw ter.f nagle.thr ft.Cl ent d
 mport com.tw ter.f nagle.thr ft.R chCl entParam
 mport com.tw ter.f nagle.ut l.DefaultT  r
 mport com.tw ter.flockdb.cl ent._
 mport com.tw ter.flockdb.cl ent.thr ftscala.FlockDB
 mport com.tw ter.fr gate.common.base.RandomRanker
 mport com.tw ter.fr gate.common.cand date._
 mport com.tw ter.fr gate.common.conf g.RateL m erGenerator
 mport com.tw ter.fr gate.common.ent y_graph_cl ent.Recom ndedT etEnt  esStore
 mport com.tw ter.fr gate.common.f lter.Dynam cRequest terF lter
 mport com.tw ter.fr gate.common. tory._
 mport com.tw ter.fr gate.common.ml.feature._
 mport com.tw ter.fr gate.common.store._
 mport com.tw ter.fr gate.common.store.dev ce nfo.Dev ce nfoStore
 mport com.tw ter.fr gate.common.store.dev ce nfo.Mob leSdkStore
 mport com.tw ter.fr gate.common.store. nterests._
 mport com.tw ter.fr gate.common.store.strato.StratoFetchableStore
 mport com.tw ter.fr gate.common.store.strato.StratoScannableStore
 mport com.tw ter.fr gate.common.ut l.F nagle.readOnlyThr ftServ ce
 mport com.tw ter.fr gate.common.ut l._
 mport com.tw ter.fr gate.data_p pel ne.features_common.FeatureStoreUt l
 mport com.tw ter.fr gate.data_p pel ne.features_common._
 mport com.tw ter.fr gate.data_p pel ne.thr ftscala.User toryKey
 mport com.tw ter.fr gate.data_p pel ne.thr ftscala.User toryValue
 mport com.tw ter.fr gate.dau_model.thr ftscala.DauProbab l y
 mport com.tw ter.fr gate.mag c_events.thr ftscala.FanoutEvent
 mport com.tw ter.fr gate.pushcap.thr ftscala.PushcapUser tory
 mport com.tw ter.fr gate.pushserv ce.model.PushTypes.PushCand date
 mport com.tw ter.fr gate.pushserv ce.model.PushTypes.Target
 mport com.tw ter.fr gate.pushserv ce.adaptor.LoggedOutPushCand dateS ceGenerator
 mport com.tw ter.fr gate.pushserv ce.adaptor.PushCand dateS ceGenerator
 mport com.tw ter.fr gate.pushserv ce.conf g.mlconf g.Deepb rdV2ModelConf g
 mport com.tw ter.fr gate.pushserv ce.ml._
 mport com.tw ter.fr gate.pushserv ce.params._
 mport com.tw ter.fr gate.pushserv ce.rank.LoggedOutRanker
 mport com.tw ter.fr gate.pushserv ce.rank.RFPHL ghtRanker
 mport com.tw ter.fr gate.pushserv ce.rank.RFPHRanker
 mport com.tw ter.fr gate.pushserv ce.rank.Subscr pt onCreatorRanker
 mport com.tw ter.fr gate.pushserv ce.refresh_handler._
 mport com.tw ter.fr gate.pushserv ce.refresh_handler.cross.Cand dateCopyExpans on
 mport com.tw ter.fr gate.pushserv ce.send_handler.SendHandlerPushCand dateHydrator
 mport com.tw ter.fr gate.pushserv ce.store._
 mport com.tw ter.fr gate.pushserv ce.take.Cand dateNot f er
 mport com.tw ter.fr gate.pushserv ce.take.Not f cat onSender
 mport com.tw ter.fr gate.pushserv ce.take.Not f cat onServ ceRequest
 mport com.tw ter.fr gate.pushserv ce.take.Not f cat onServ ceSender
 mport com.tw ter.fr gate.pushserv ce.take.NtabOnlyChannelSelector
 mport com.tw ter.fr gate.pushserv ce.take. tory.EventBusWr er
 mport com.tw ter.fr gate.pushserv ce.take. tory. toryWr er
 mport com.tw ter.fr gate.pushserv ce.take.sender. b s2Sender
 mport com.tw ter.fr gate.pushserv ce.take.sender.NtabSender
 mport com.tw ter.fr gate.pushserv ce.take.LoggedOutRefreshForPushNot f er
 mport com.tw ter.fr gate.pushserv ce.ut l.RFPHTakeStepUt l
 mport com.tw ter.fr gate.pushserv ce.ut l.SendHandlerPred cateUt l
 mport com.tw ter.fr gate.scr be.thr ftscala.Not f cat onScr be
 mport com.tw ter.fr gate.thr ftscala._
 mport com.tw ter.fr gate.user_states.thr ftscala.MRUserHmmState
 mport com.tw ter.geoduck.backend.hydrat on.thr ftscala.Hydrat on
 mport com.tw ter.geoduck.common.thr ftscala.PlaceQueryF elds
 mport com.tw ter.geoduck.common.thr ftscala.PlaceType
 mport com.tw ter.geoduck.common.thr ftscala.{Locat on => GeoLocat on}
 mport com.tw ter.geoduck.serv ce.common.cl entmodules.GeoduckUserLocate
 mport com.tw ter.geoduck.serv ce.common.cl entmodules.GeoduckUserLocateModule
 mport com.tw ter.geoduck.serv ce.thr ftscala.Locat onResponse
 mport com.tw ter.geoduck.thr ftscala.Locat onServ ce
 mport com.tw ter.g zmoduck.context.thr ftscala.ReadConf g
 mport com.tw ter.g zmoduck.context.thr ftscala.TestUserConf g
 mport com.tw ter.g zmoduck.testusers.cl ent.TestUserCl entBu lder
 mport com.tw ter.g zmoduck.thr ftscala.LookupContext
 mport com.tw ter.g zmoduck.thr ftscala.QueryF elds
 mport com.tw ter.g zmoduck.thr ftscala.User
 mport com.tw ter.g zmoduck.thr ftscala.UserServ ce
 mport com.tw ter. rm .pop_geo.thr ftscala.PopT ets nPlace
 mport com.tw ter. rm .pred cate.soc algraph.Soc alGraphPred cate
 mport com.tw ter. rm .pred cate.t etyp e.Perspect veReadableStore
 mport com.tw ter. rm .store._
 mport com.tw ter. rm .store.common._
 mport com.tw ter. rm .store.g zmoduck.G zmoduckUserStore
 mport com.tw ter. rm .store. tastore.UserCountryStore
 mport com.tw ter. rm .store. tastore.UserLanguagesStore
 mport com.tw ter. rm .store.scarecrow.ScarecrowC ckEventStore
 mport com.tw ter. rm .store.semant c_core. taDataReadableStore
 mport com.tw ter. rm .store.semant c_core.Semant cEnt yForQuery
 mport com.tw ter. rm .store.t  zone.G zmoduckUserUtcOffsetStore
 mport com.tw ter. rm .store.t  zone.UtcOffsetStore
 mport com.tw ter. rm .store.t etyp e.T etyP eStore
 mport com.tw ter. rm .store.t etyp e.UserT et
 mport com.tw ter. rm .store.user_htl_sess on_store.UserHTLLastV s ReadableStore
 mport com.tw ter. rm .stp.thr ftscala.STPResult
 mport com.tw ter.hss.ap .thr ftscala.User althS gnal
 mport com.tw ter.hss.ap .thr ftscala.User althS gnal._
 mport com.tw ter.hss.ap .thr ftscala.User althS gnalResponse
 mport com.tw ter. nterests.thr ftscala. nterest d
 mport com.tw ter. nterests.thr ftscala. nterestsThr ftServ ce
 mport com.tw ter. nterests.thr ftscala.{User nterests =>  nterests}
 mport com.tw ter. nterests_d scovery.thr ftscala. nterestsD scoveryServ ce
 mport com.tw ter. nterests_d scovery.thr ftscala.NonPersonal zedRecom ndedL sts
 mport com.tw ter. nterests_d scovery.thr ftscala.Recom ndedL stsRequest
 mport com.tw ter. nterests_d scovery.thr ftscala.Recom ndedL stsResponse
 mport com.tw ter.kujaku.doma n.thr ftscala.Mach neTranslat onResponse
 mport com.tw ter.l vev deo.t  l ne.cl ent.v2.L veV deoT  l neCl ent
 mport com.tw ter.l vev deo.t  l ne.doma n.v2.{Event => L veEvent}
 mport com.tw ter.l vev deo.t  l ne.thr ft.thr ftscala.T  l neServ ce
 mport com.tw ter.logg ng.Logger
 mport com.tw ter.ml.ap .thr ftscala.{DataRecord => Thr ftDataRecord}
 mport com.tw ter.ml.featurestore.catalog.ent  es.core.{Author => T etAuthorEnt y}
 mport com.tw ter.ml.featurestore.catalog.ent  es.core.{User => TargetUserEnt y}
 mport com.tw ter.ml.featurestore.catalog.ent  es.core.{UserAuthor => UserAuthorEnt y}
 mport com.tw ter.ml.featurestore.catalog.ent  es.mag crecs.{Soc alContext => Soc alContextEnt y}
 mport com.tw ter.ml.featurestore.catalog.ent  es.mag crecs.{UserSoc alContext => TargetUserSoc alContextEnt y}
 mport com.tw ter.ml.featurestore.t  l nes.thr ftscala.T  l neScorerScoreV ew
 mport com.tw ter.not f cat onserv ce.ap .thr ftscala.DeleteCurrentT  l neForUserRequest
 mport com.tw ter.not f cat onserv ce.gener cfeedbackstore.FeedbackPromptValue
 mport com.tw ter.not f cat onserv ce.gener cfeedbackstore.Gener cFeedbackStore
 mport com.tw ter.not f cat onserv ce.gener cfeedbackstore.Gener cFeedbackStoreBu lder
 mport com.tw ter.not f cat onserv ce.scr be.manhattan.FeedbackS gnalManhattanCl ent
 mport com.tw ter.not f cat onserv ce.scr be.manhattan.Gener cNot f cat onsFeedbackRequest
 mport com.tw ter.not f cat onserv ce.thr ftscala.CaretFeedbackDeta ls
 mport com.tw ter.not f cat onserv ce.thr ftscala.CreateGener cNot f cat onRequest
 mport com.tw ter.not f cat onserv ce.thr ftscala.CreateGener cNot f cat onResponse
 mport com.tw ter.not f cat onserv ce.thr ftscala.DeleteGener cNot f cat onRequest
 mport com.tw ter.not f cat onserv ce.thr ftscala.Gener cNot f cat onOverr deKey
 mport com.tw ter.not f cat onserv ce.thr ftscala.Not f cat onServ ce$F nagleCl ent
 mport com.tw ter.nrel. avyranker.Cand dateFeatureHydrator
 mport com.tw ter.nrel. avyranker.FeatureHydrator
 mport com.tw ter.nrel. avyranker.{PushPred ct onServ ceStore => RelevancePushPred ct onServ ceStore}
 mport com.tw ter.nrel. avyranker.{TargetFeatureHydrator => RelevanceTargetFeatureHydrator}
 mport com.tw ter.nrel.l ghtranker.Mag cRecsServeDataRecordL ghtRanker
 mport com.tw ter.nrel.l ghtranker.{Conf g => L ghtRankerConf g}
 mport com.tw ter.onboard ng.task.serv ce.thr ftscala.Fat gueFlowEnroll nt
 mport com.tw ter.per scope.ap .thr ftscala.Aud oSpacesLookupContext
 mport com.tw ter.perm ss ons_storage.thr ftscala.AppPerm ss on
 mport com.tw ter.recom ndat on. nterests.d scovery.core.conf g.{DeployConf g =>  nterestDeployConf g}
 mport com.tw ter.recom ndat on. nterests.d scovery.popgeo.deploy.PopGeo nterestProv der
 mport com.tw ter.recos.user_t et_ent y_graph.thr ftscala.UserT etEnt yGraph
 mport com.tw ter.recos.user_user_graph.thr ftscala.UserUserGraph
 mport com.tw ter.rux.common.strato.thr ftscala.UserTarget ngProperty
 mport com.tw ter.sc o.nsfw_user_seg ntat on.thr ftscala.NSFWProducer
 mport com.tw ter.sc o.nsfw_user_seg ntat on.thr ftscala.NSFWUserSeg ntat on
 mport com.tw ter.search.earlyb rd.thr ftscala.Earlyb rdServ ce
 mport com.tw ter.serv ce.gen.scarecrow.thr ftscala.ScarecrowServ ce
 mport com.tw ter.serv ce. tastore.gen.thr ftscala.Locat on
 mport com.tw ter.s mclusters_v2.thr ftscala.S mClusters nferredEnt  es
 mport com.tw ter.soc algraph.thr ftscala.Soc alGraphServ ce
 mport com.tw ter.spam.rtf.thr ftscala.SafetyLevel
 mport com.tw ter.st ch.t etyp e.T etyP e.T etyP eResult
 mport com.tw ter.storage.cl ent.manhattan.kv.Guarantee
 mport com.tw ter.storage.cl ent.manhattan.kv.ManhattanKVCl ent
 mport com.tw ter.storage.cl ent.manhattan.kv.ManhattanKVCl entMtlsParams
 mport com.tw ter.storage.cl ent.manhattan.kv.ManhattanKVEndpo nt
 mport com.tw ter.storage.cl ent.manhattan.kv.ManhattanKVEndpo ntBu lder
 mport com.tw ter.storehaus.ReadableStore
 mport com.tw ter.storehaus_ nternal.manhattan.Apollo
 mport com.tw ter.storehaus_ nternal.manhattan.At na
 mport com.tw ter.storehaus_ nternal.manhattan.Dataset
 mport com.tw ter.storehaus_ nternal.manhattan.ManhattanStore
 mport com.tw ter.storehaus_ nternal.manhattan.Nash
 mport com.tw ter.storehaus_ nternal.manhattan.O ga
 mport com.tw ter.storehaus_ nternal. mcac . mcac Store
 mport com.tw ter.storehaus_ nternal.ut l.Cl entNa 
 mport com.tw ter.storehaus_ nternal.ut l.ZkEndPo nt
 mport com.tw ter.strato.catalog.Scan.Sl ce
 mport com.tw ter.strato.cl ent.Strato
 mport com.tw ter.strato.cl ent.User d
 mport com.tw ter.strato.columns.fr gate.logged_out_ b_not f cat ons.thr ftscala.LO bNot f cat on tadata
 mport com.tw ter.strato.columns.not f cat ons.thr ftscala.S ceDestUserRequest
 mport com.tw ter.strato.generated.cl ent.geo.user.FrequentSoftUserLocat onCl entColumn
 mport com.tw ter.strato.generated.cl ent.ml.featureStore.T  l neScorerT etScoresV1Cl entColumn
 mport com.tw ter.strato.generated.cl ent.not f cat ons.space_dev ce_follow_ mpl.SpaceDev ceFollow ngCl entColumn
 mport com.tw ter.strato.generated.cl ent.per scope.CoreOnAud oSpaceCl entColumn
 mport com.tw ter.strato.generated.cl ent.per scope.Part c pantsOnAud oSpaceCl entColumn
 mport com.tw ter.strato.generated.cl ent.rux.Target ngPropertyOnUserCl entColumn
 mport com.tw ter.strato.generated.cl ent.soc algraph.graphs.creatorSubscr pt onT  l ne.{CountEdgesByS ceCl entColumn => CreatorSubscr pt onNumT etsColumn}
 mport com.tw ter.strato.generated.cl ent.translat on.serv ce. sT etTranslatableCl entColumn
 mport com.tw ter.strato.generated.cl ent.translat on.serv ce.platform.Mach neTranslateT etCl entColumn
 mport com.tw ter.strato.generated.cl ent.trends.tr p.Tr pT etsA rflowProdCl entColumn
 mport com.tw ter.strato.thr ft.ScroogeConv mpl c s._
 mport com.tw ter.tax .common.App d
 mport com.tw ter.tax .deploy.Cluster
 mport com.tw ter.tax .deploy.Env
 mport com.tw ter.top cl st ng.Top cL st ng
 mport com.tw ter.top cl st ng.Top cL st ngBu lder
 mport com.tw ter.trends.tr p_v1.tr p_t ets.thr ftscala.Tr pDoma n
 mport com.tw ter.trends.tr p_v1.tr p_t ets.thr ftscala.Tr pT ets
 mport com.tw ter.tsp.thr ftscala.Top cSoc alProofRequest
 mport com.tw ter.tsp.thr ftscala.Top cSoc alProofResponse
 mport com.tw ter.t etyp e.thr ftscala.GetT etOpt ons
 mport com.tw ter.t etyp e.thr ftscala.T et.V s bleTextRangeF eld
 mport com.tw ter.t etyp e.thr ftscala.T etServ ce
 mport com.tw ter.ubs.thr ftscala.Aud oSpace
 mport com.tw ter.ubs.thr ftscala.Part c pants
 mport com.tw ter.ubs.thr ftscala.SellerAppl cat onState
 mport com.tw ter.user_sess on_store.thr ftscala.UserSess on
 mport com.tw ter.ut l.Durat on
 mport com.tw ter.ut l.Future
 mport com.tw ter.ut l.T  r
 mport com.tw ter.ut l.tunable.TunableMap
 mport com.tw ter.wtf.scald ng.common.thr ftscala.UserFeatures
 mport org.apac .thr ft.protocol.TCompactProtocol
 mport com.tw ter.t  l nescorer.thr ftscala.v1.ScoredT et
 mport com.tw ter.ubs.thr ftscala.SellerTrack
 mport com.tw ter.wtf.cand date.thr ftscala.Cand dateSeq

tra  DeployConf g extends Conf g {
  // Any f nagle cl ents should not be def ned as lazy.  f def ned lazy,
  // Cl entReg stry.expAllReg steredCl entsResolved() call  n  n  w ll not ensure that t  cl ents
  // are act ve before thr ft endpo nt  s act ve.   want t  cl ents to be act ve, because zookeeper
  // resolut on tr ggered by f rst request(s) m ght result  n t  request(s) fa l ng.

  def serv ce dent f er: Serv ce dent f er

  def tunableMap: TunableMap

  def featureSw c s: FeatureSw c s

  overr de val  sProd: Boolean =
    serv ce dent f er.env ron nt == PushConstants.Serv ceProdEnv ron ntNa 

  def shardParams: ShardParams

  def log: Logger

   mpl c  def statsRece ver: StatsRece ver

   mpl c  val t  r: T  r = DefaultT  r

  def not f erThr ftCl ent d: Cl ent d

  def loggedOutNot f erThr ftCl ent d: Cl ent d

  def pushserv ceThr ftCl ent d: Cl ent d

  def deepb rdv2Pred ct onServ ceDest: Str ng

  def featureStoreUt l: FeatureStoreUt l

  def targetLevelFeaturesConf g: PushFeaturesConf g

  pr vate val manhattanCl entMtlsParams = ManhattanKVCl entMtlsParams(
    serv ce dent f er = serv ce dent f er,
    opportun st cTls = Opportun st cTls.Requ red
  )

  // Commonly used cl ents
  val g zmoduckCl ent = {

    val cl ent = Thr ftMux.cl ent
      .w hMutualTls(serv ce dent f er)
      .w hCl ent d(pushserv ceThr ftCl ent d)
      .bu ld[UserServ ce. thodPerEndpo nt](
        dest = "/s/g zmoduck/g zmoduck"
      )

    /**
     * RequestContext test user conf g to allow read ng test user accounts on pushserv ce for load
     * test ng
     */
    val G zmoduckTestUserConf g = TestUserConf g(
      cl ent d = So (pushserv ceThr ftCl ent d.na ),
      readConf g = So (ReadConf g( ncludeTestUsers = true))
    )

    TestUserCl entBu lder[UserServ ce. thodPerEndpo nt]
      .w hCl ent(cl ent)
      .w hConf g(G zmoduckTestUserConf g)
      .bu ld()
  }

  val sgsCl ent = {
    val serv ce = readOnlyThr ftServ ce(
      "",
      "/s/soc algraph/soc algraph",
      statsRece ver,
      pushserv ceThr ftCl ent d,
      mTLSServ ce dent f er = So (serv ce dent f er)
    )
    new Soc alGraphServ ce.F nagledCl ent(serv ce)
  }

  val t etyP eCl ent = {
    val serv ce = readOnlyThr ftServ ce(
      "",
      "/s/t etyp e/t etyp e",
      statsRece ver,
      not f erThr ftCl ent d,
      mTLSServ ce dent f er = So (serv ce dent f er)
    )
    new T etServ ce.F nagledCl ent(serv ce)
  }

  lazy val geoduckHydrat onCl ent: Hydrat on. thodPerEndpo nt = {
    val serv cePerEndpo nt = Thr ftMux.cl ent
      .w hLabel("geoduck_hydrat on")
      .w hCl ent d(pushserv ceThr ftCl ent d)
      .w hMutualTls(serv ce dent f er)
      . thodBu lder("/s/geo/hydrat on")
      .w hT  outPerRequest(10.seconds)
      .w hT  outTotal(10.seconds)
      . dempotent(maxExtraLoad = 0.0)
      .serv cePerEndpo nt[Hydrat on.Serv cePerEndpo nt]
    Hydrat on. thodPerEndpo nt(serv cePerEndpo nt)
  }

  lazy val geoduckLocat onCl ent: Locat onServ ce. thodPerEndpo nt = {
    val serv cePerEndpo nt = Thr ftMux.cl ent
      .w hLabel("geoduck_locat on")
      .w hCl ent d(pushserv ceThr ftCl ent d)
      .w hMutualTls(serv ce dent f er)
      . thodBu lder("/s/geo/geoduck_locat onserv ce")
      .w hT  outPerRequest(10.seconds)
      .w hT  outTotal(10.seconds)
      . dempotent(maxExtraLoad = 0.0)
      .serv cePerEndpo nt[Locat onServ ce.Serv cePerEndpo nt]
    Locat onServ ce. thodPerEndpo nt(serv cePerEndpo nt)
  }

  overr de val geoDuckV2Store: ReadableStore[Long, Locat onResponse] = {
    val geoduckLocate: GeoduckUserLocate = GeoduckUserLocateModule.prov desGeoduckUserLocate(
      locat onServ ceCl ent = geoduckLocat onCl ent,
      hydrat onCl ent = geoduckHydrat onCl ent,
      unscopedStatsRece ver = statsRece ver
    )

    val store: ReadableStore[Long, Locat onResponse] = ReadableStore
      .convert[GeoduckRequest, Long, Locat onResponse, Locat onResponse](
        GeoduckStoreV2(geoduckLocate))({ user d: Long =>
        GeoduckRequest(
          user d,
          placeTypes = Set(
            PlaceType.C y,
            PlaceType. tro,
            PlaceType.Country,
            PlaceType.Z pCode,
            PlaceType.Adm n0,
            PlaceType.Adm n1),
          placeF elds = Set(PlaceQueryF elds.PlaceNa s),
           ncludeCountryCode = true
        )
      })({ locat onResponse: Locat onResponse => Future.value(locat onResponse) })

    val _cac Na  = "geoduckv2_ n_ mory_cac "
    ObservedCac dReadableStore.from(
      store,
      ttl = 20.seconds,
      maxKeys = 1000,
      cac Na  = _cac Na ,
      w ndowS ze = 10000L
    )(statsRece ver.scope(_cac Na ))
  }

  pr vate val deepb rdServ ceBase = Thr ftMux.cl ent
    .w hCl ent d(pushserv ceThr ftCl ent d)
    .w hMutualTls(serv ce dent f er)
    .w hLoadBalancer(Balancers.p2c())
    .newServ ce(deepb rdv2Pred ct onServ ceDest, "Deepb rdV2Pred ct onServ ce")
  val deepb rdPred ct onServ ceCl ent = new Deepb rdPred ct onServ ce.Serv ceToCl ent(
    F nagle
      .retryReadF lter(
        tr es = 3,
        statsRece ver = statsRece ver.scope("Deepb rdV2Pred ct onServ ce"))
      .andT n(F nagle.t  outF lter(t  out = 10.seconds))
      .andT n(deepb rdServ ceBase),
    R chCl entParam(serv ceNa  = "Deepb rdV2Pred ct onServ ce", cl entStats = statsRece ver)
  )

  val manhattanStarbuckApp d = "fr gate_pushserv ce_starbuck"
  val  tastoreLocat onApp d = "fr gate_not f er_ tastore_locat on"
  val manhattan tastoreApp d = "fr gate_pushserv ce_pengu n"

  def pushServ ceMHCac Dest: Str ng
  def pushServ ceCoreSvcsCac Dest: Str ng
  def poptart mpress onsCac Dest: Str ng = "/srv#/prod/local/cac /poptart_ mpress ons"
  def ent yGraphCac Dest: Str ng

  val pushServ ceCac Cl ent: Cl ent =  mcac Store. mcac dCl ent(
    na  = Cl entNa (" mcac -pushserv ce"),
    dest = ZkEndPo nt(pushServ ceMHCac Dest),
    statsRece ver = statsRece ver,
    t  out = 2.seconds,
    serv ce dent f er = serv ce dent f er
  )

  val pushServ ceCoreSvcsCac Cl ent: Cl ent =
     mcac Store. mcac dCl ent(
      na  = Cl entNa (" mcac -pushserv ce-core-svcs"),
      dest = ZkEndPo nt(pushServ ceCoreSvcsCac Dest),
      statsRece ver = statsRece ver,
      serv ce dent f er = serv ce dent f er,
      t  out = 2.seconds,
    )

  val poptart mpress onsCac Cl ent: Cl ent =
     mcac Store. mcac dCl ent(
      na  = Cl entNa (" mcac -pushserv ce-poptart- mpress ons"),
      dest = ZkEndPo nt(poptart mpress onsCac Dest),
      statsRece ver = statsRece ver,
      serv ce dent f er = serv ce dent f er,
      t  out = 2.seconds
    )

  val ent yGraphCac Cl ent: Cl ent =  mcac Store. mcac dCl ent(
    na  = Cl entNa (" mcac -pushserv ce-ent y-graph"),
    dest = ZkEndPo nt(ent yGraphCac Dest),
    statsRece ver = statsRece ver,
    serv ce dent f er = serv ce dent f er,
    t  out = 2.seconds
  )

  val stratoCl ent = {
    val pushserv ceThr ftCl ent = Thr ftMux.cl ent.w hCl ent d(pushserv ceThr ftCl ent d)
    val baseBu lder = Strato
      .Cl ent(pushserv ceThr ftCl ent)
      .w hMutualTls(serv ce dent f er)
    val f nalBu lder =  f ( sServ ceLocal) {
      baseBu lder.w hRequestT  out(Durat on.fromSeconds(15))
    } else {
      baseBu lder.w hRequestT  out(Durat on.fromSeconds(3))
    }
    f nalBu lder.bu ld()
  }

  val  nterestThr ftServ ceCl ent = Thr ftMux.cl ent
    .w hCl ent d(pushserv ceThr ftCl ent d)
    .w hMutualTls(serv ce dent f er)
    .w hRequestT  out(3.seconds)
    .conf gured(Retr es.Pol cy(RetryPol cy.tr es(1)))
    .conf gured(BackupRequestF lter.Conf gured(maxExtraLoad = 0.0, send nterrupts = false))
    .w hStatsRece ver(statsRece ver)
    .bu ld[ nterestsThr ftServ ce. thodPerEndpo nt](
      dest = "/s/ nterests-thr ft-serv ce/ nterests-thr ft-serv ce",
      label = " nterests-lookup"
    )

  def  mcac CASDest: Str ng

  overr de val casLock: CasLock = {
    val mag crecsCas mcac Cl ent =  mcac d.cl ent
      .w hMutualTls(serv ce dent f er)
      .w hLabel("mr-cas- mcac -cl ent")
      .w hRequestT  out(3.seconds)
      .w hStatsRece ver(statsRece ver)
      .conf gured(Retr es.Pol cy(RetryPol cy.tr es(3)))
      .newT mcac Cl ent( mcac CASDest)
      .w hStr ngs

     mcac CasLock(mag crecsCas mcac Cl ent)
  }

  overr de val push nfoStore: ReadableStore[Long, UserForPushTarget ng] = {
    StratoFetchableStore.w hUn V ew[Long, UserForPushTarget ng](
      stratoCl ent,
      "fr gate/mag crecs/pushRecsTarget ng.User")
  }

  overr de val loggedOutPush nfoStore: ReadableStore[Long, LO bNot f cat on tadata] = {
    StratoFetchableStore.w hUn V ew[Long, LO bNot f cat on tadata](
      stratoCl ent,
      "fr gate/mag crecs/ b/loggedOut bUserStoreMh"
    )
  }

  // Sett ng up model stores
  overr de val dauProbab l yStore: ReadableStore[Long, DauProbab l y] = {
    StratoFetchableStore
      .w hUn V ew[Long, DauProbab l y](stratoCl ent, "fr gate/mag crecs/dauProbab l y.User")
  }

  overr de val nsfwConsu rStore = {
    StratoFetchableStore.w hUn V ew[Long, NSFWUserSeg ntat on](
      stratoCl ent,
      "fr gate/nsfw-user-seg ntat on/nsfwUserSeg ntat on.User")
  }

  overr de val nsfwProducerStore = {
    StratoFetchableStore.w hUn V ew[Long, NSFWProducer](
      stratoCl ent,
      "fr gate/nsfw-user-seg ntat on/nsfwProducer.User"
    )
  }

  overr de val  dsStore: ReadableStore[Recom ndedL stsRequest, Recom ndedL stsResponse] = {
    val serv ce = F nagle.readOnlyThr ftServ ce(
      na  = " nterests-d scovery-serv ce",
      dest = "/s/ nterests_d scovery/ nterests_d scovery",
      statsRece ver,
      pushserv ceThr ftCl ent d,
      requestT  out = 4.seconds,
      tr es = 2,
      mTLSServ ce dent f er = So (serv ce dent f er)
    )
    val cl ent = new  nterestsD scoveryServ ce.F nagledCl ent(
      serv ce = serv ce,
      R chCl entParam(serv ceNa  = " nterests-d scovery-serv ce")
    )

     nterestD scoveryStore(cl ent)
  }

  overr de val popGeoL sts = {
    StratoFetchableStore.w hUn V ew[Str ng, NonPersonal zedRecom ndedL sts](
      stratoCl ent,
      column = "recom ndat ons/ nterests_d scovery/recom ndat ons_mh/Organ cPopgeoL sts"
    )
  }

  overr de val l stAP Store = {
    val fetc r = stratoCl ent
      .fetc r[Long, Ap L stV ew, Ap L st]("channels/hydrat on/ap L st.L st")
    StratoFetchableStore.w hV ew[Long, Ap L stV ew, Ap L st](
      fetc r,
      Ap L stV ew(Ap L stD splayLocat on.Recom ndat ons)
    )
  }

  overr de val react vatedUser nfoStore = {
    val stratoFetchableStore = StratoFetchableStore
      .w hUn V ew[Long, Str ng](stratoCl ent, "ml/featureStore/recentReact vat onT  .User")

    ObservedReadableStore(
      stratoFetchableStore
    )(statsRece ver.scope("RecentReact vat onT  "))
  }

  overr de val openedPushByH AggregatedStore: ReadableStore[Long, Map[ nt,  nt]] = {
    StratoFetchableStore
      .w hUn V ew[Long, Map[ nt,  nt]](
        stratoCl ent,
        "fr gate/mag crecs/opendPushByH Aggregated.User")
  }

  pr vate val lexCl ent: L veV deoT  l neCl ent = {
    val lexServ ce =
      new T  l neServ ce.F nagledCl ent(
        readOnlyThr ftServ ce(
          na  = "lex",
          dest = lexServ ceDest,
          statsRece ver = statsRece ver.scope("lex-serv ce"),
          thr ftCl ent d = pushserv ceThr ftCl ent d,
          requestT  out = 5.seconds,
          mTLSServ ce dent f er = So (serv ce dent f er)
        ),
        cl entParam = R chCl entParam(serv ceNa  = "lex")
      )
    new L veV deoT  l neCl ent(lexServ ce)
  }

  overr de val lexServ ceStore = {
    ObservedCac dReadableStore.from[EventRequest, L veEvent](
      bu ldStore(LexServ ceStore(lexCl ent), "lexServ ceStore"),
      ttl = 1.h ,
      maxKeys = 1000,
      cac Na  = "lexServ ceStore_cac ",
      w ndowS ze = 10000L
    )(statsRece ver.scope("lexServ ceStore_cac "))
  }

  val  nferredEnt  esFrom nterested nKeyedByClusterColumn =
    "recom ndat ons/s mclusters_v2/ nferred_ent  es/ nferredEnt  esFrom nterested nKeyedByCluster"
  overr de val s mClusterToEnt yStore: ReadableStore[ nt, S mClusters nferredEnt  es] = {
    val store = StratoFetchableStore
      .w hUn V ew[ nt, S mClusters nferredEnt  es](
        stratoCl ent,
         nferredEnt  esFrom nterested nKeyedByClusterColumn)
    ObservedCac dReadableStore.from[ nt, S mClusters nferredEnt  es](
      bu ldStore(store, "s mcluster_ent y_store_cac "),
      ttl = 6.h s,
      maxKeys = 1000,
      cac Na  = "s mcluster_ent y_store_cac ",
      w ndowS ze = 10000L
    )(statsRece ver.scope("s mcluster_ent y_store_cac "))
  }

  def fanout tadataColumn: Str ng

  overr de val fanout tadataStore: ReadableStore[(Long, Long), FanoutEvent] = {
    val store = StratoFetchableStore
      .w hUn V ew[(Long, Long), FanoutEvent](stratoCl ent, fanout tadataColumn)
    ObservedCac dReadableStore.from[(Long, Long), FanoutEvent](
      bu ldStore(store, "fanout tadataStore"),
      ttl = 10.m nutes,
      maxKeys = 1000,
      cac Na  = "fanout tadataStore_cac ",
      w ndowS ze = 10000L
    )(statsRece ver.scope("fanout tadataStore_cac "))
  }

  /**
   * PostRank ng Feature Store Cl ent
   */
  overr de def postRank ngFeatureStoreCl ent = {
    val cl entStats = statsRece ver.scope("post_rank ng_feature_store_cl ent")
    val cl entConf g =
      FeatureStoreCl entBu lder.getCl entConf g(PostRank ngFeaturesConf g(), featureStoreUt l)

    FeatureStoreCl entBu lder.getDynam cFeatureStoreCl ent(cl entConf g, cl entStats)
  }

  /**
   *  nterests lookup store
   */
  overr de val  nterestsW hLookupContextStore = {
    ObservedCac dReadableStore.from[ nterestsLookupRequestW hContext,  nterests](
      bu ldStore(
        new  nterestsW hLookupContextStore( nterestThr ftServ ceCl ent, statsRece ver),
        " nterestsW hLookupContextStore"
      ),
      ttl = 1.m nute,
      maxKeys = 1000,
      cac Na  = " nterestsW hLookupContextStore_cac ",
      w ndowS ze = 10000L
    )
  }

  /**
   * OptOut nterestsStore
   */
  overr de lazy val optOutUser nterestsStore: ReadableStore[Long, Seq[ nterest d]] = {
    bu ldStore(
       nterestsOptOutw hLookUpContextStore( nterestThr ftServ ceCl ent),
      " nterestsOptOutStore"
    )
  }

  overr de val top cL st ng: Top cL st ng =
     f ( sServ ceLocal) {
      new Top cL st ngBu lder(statsRece ver.scope("top cl st ng"), So (localConf gRepoPath)).bu ld
    } else {
      new Top cL st ngBu lder(statsRece ver.scope("top cl st ng"), None).bu ld
    }

  val cac dUttCl ent = {
    val DefaultUttCac Conf g = Cac Conf gV2(capac y = 100)
    val uttCl entCac Conf gs = uttcl ent.UttCl entCac Conf gsV2(
      DefaultUttCac Conf g,
      DefaultUttCac Conf g,
      DefaultUttCac Conf g,
      DefaultUttCac Conf g
    )
    new Cac dUttCl entV2(stratoCl ent, Env ron nt.Prod, uttCl entCac Conf gs, statsRece ver)
  }

  overr de val uttEnt yHydrat onStore =
    new UttEnt yHydrat onStore(cac dUttCl ent, statsRece ver, log)

  pr vate lazy val dbv2Pred ct onServ ceScoreStore: RelevancePushPred ct onServ ceStore =
    Deepb rdV2ModelConf g.bu ldPred ct onServ ceScoreStore(
      deepb rdPred ct onServ ceCl ent,
      "deepb rdv2_mag crecs"
    )

  // Custom zed model to Pred ct onServ ceStoreMap
  //    s used to spec fy t  pred ct onServ ceStore for t  models not  n t  default dbv2Pred ct onServ ceScoreStore
  pr vate lazy val modelToPred ct onServ ceStoreMap: Map[
      ghtedOpenOrNtabCl ckModel.ModelNa Type,
    RelevancePushPred ct onServ ceStore
  ] = Map()

  overr de lazy val   ghtedOpenOrNtabCl ckModelScorer = new PushMLModelScorer(
    PushMLModel.  ghtedOpenOrNtabCl ckProbab l y,
    modelToPred ct onServ ceStoreMap,
    dbv2Pred ct onServ ceScoreStore,
    statsRece ver.scope("  ghted_oonc_scor ng")
  )

  overr de lazy val optoutModelScorer = new PushMLModelScorer(
    PushMLModel.OptoutProbab l y,
    Map.empty,
    dbv2Pred ct onServ ceScoreStore,
    statsRece ver.scope("optout_scor ng")
  )

  overr de lazy val f lter ngModelScorer = new PushMLModelScorer(
    PushMLModel.F lter ngProbab l y,
    Map.empty,
    dbv2Pred ct onServ ceScoreStore,
    statsRece ver.scope("f lter ng_scor ng")
  )

  pr vate val queryF elds: Set[QueryF elds] = Set(
    QueryF elds.Prof le,
    QueryF elds.Account,
    QueryF elds.Roles,
    QueryF elds.D scoverab l y,
    QueryF elds.Safety,
    QueryF elds.Takedowns,
    QueryF elds.Labels,
    QueryF elds.Counts,
    QueryF elds.ExtendedProf le
  )

  // Sett ng up safeUserStore
  overr de val safeUserStore =
    //  n- mory cac 
    ObservedCac dReadableStore.from[Long, User](
      ObservedReadableStore(
        G zmoduckUserStore.safeStore(
          cl ent = g zmoduckCl ent,
          queryF elds = queryF elds,
          safetyLevel = SafetyLevel.F lterNone,
          statsRece ver = statsRece ver
        )
      )(statsRece ver.scope("SafeUserStore")),
      ttl = 1.m nute,
      maxKeys = 5e4.to nt,
      cac Na  = "safeUserStore_cac ",
      w ndowS ze = 10000L
    )(statsRece ver.scope("safeUserStore_cac "))

  val mob leSdkStore = Mob leSdkStore(
    "fr gate_mob le_sdk_vers on_apollo",
    "mob le_sdk_vers ons_scald ng",
    manhattanCl entMtlsParams,
    Apollo
  )

  val dev ceUserStore = ObservedReadableStore(
    G zmoduckUserStore(
      cl ent = g zmoduckCl ent,
      queryF elds = Set(QueryF elds.Dev ces),
      context = LookupContext( ncludeSoftUsers = true),
      statsRece ver = statsRece ver
    )
  )(statsRece ver.scope("dev cesUserStore"))

  overr de val dev ce nfoStore = Dev ce nfoStore(
    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = ObservedReadableStore(
        mob leSdkStore
      )(statsRece ver.scope("uncac dMob leSdkVers onsStore")),
      cac Cl ent = pushServ ceCac Cl ent,
      ttl = 12.h s
    )(
      value nject on = B naryScalaCodec(SdkVers onValue),
      statsRece ver = statsRece ver.scope("Mob leSdkVers onsStore"),
      keyToStr ng = {
        case SdkVers onKey(So (user d), So (cl ent d)) =>
          s"Dev ce nfoStore/$user d/$cl ent d"
        case SdkVers onKey(So (user d), None) => s"Dev ce nfoStore/$user d/_"
        case SdkVers onKey(None, So (cl ent d)) =>
          s"Dev ce nfoStore/_/$cl ent d"
        case SdkVers onKey(None, None) => s"Dev ce nfoStore/_"
      }
    ),
    dev ceUserStore
  )

  // Sett ng up edgeStore
  overr de val edgeStore = Soc alGraphPred cate.bu ldEdgeStore(sgsCl ent)

  overr de val soc alGraphServ ceProcessStore = Soc alGraphServ ceProcessStore(edgeStore)

  def userT etEnt yGraphDest: Str ng
  def userUserGraphDest: Str ng
  def lexServ ceDest: Str ng

  // Sett ng up t   tory store
  def fr gate toryCac Dest: Str ng

  val not f cat on toryStore: Not f cat on toryStore = {

    val manhattanStackBasedCl ent = Thr ftMux.cl ent
      .w hCl ent d(not f erThr ftCl ent d)
      .w hOpportun st cTls(Opportun st cTls.Requ red)
      .w hMutualTls(
        serv ce dent f er
      )

    val manhattan tory thodBu lder = manhattanStackBasedCl ent
      .w hLabel("manhattan_ tory_v2")
      .w hRequestT  out(10.seconds)
      .w hStatsRece ver(statsRece ver)
      . thodBu lder(O ga.w lyNa )
      .w hMaxRetr es(3)

    Not f cat on toryStore.bu ld(
      "fr gate_not f er",
      "fr gate_not f cat ons_v2",
      manhattan tory thodBu lder,
      maxRetryCount = 3
    )
  }

  val ema lNot f cat on toryStore: ReadOnly toryStore = {
    val cl ent = ManhattanKVCl ent(
      app d = "fr gate_ema l_ tory",
      dest = "/s/manhattan/o ga.nat ve-thr ft",
      mtlsParams = ManhattanKVCl entMtlsParams(
        serv ce dent f er = serv ce dent f er,
        opportun st cTls = Opportun st cTls.Requ red
      )
    )
    val endpo nt = ManhattanKVEndpo ntBu lder(cl ent)
      .defaultGuarantee(Guarantee.SoftDcRead Wr es)
      .statsRece ver(statsRece ver)
      .bu ld()

    ReadOnly toryStore(ManhattanKV toryStore(endpo nt, dataset = "fr gate_ema l_ tory"))(
      statsRece ver)
  }

  val manhattanKVLoggedOut toryStoreEndpo nt: ManhattanKVEndpo nt = {
    val mhCl ent = ManhattanKVCl ent(
      "fr gate_not f cat on_logged_out_ tory",
      Nash.w lyNa ,
      manhattanCl entMtlsParams)
    ManhattanKVEndpo ntBu lder(mhCl ent)
      .defaultGuarantee(Guarantee.SoftDcRead Wr es)
      .defaultMaxT  out(5.seconds)
      .maxRetryCount(3)
      .statsRece ver(statsRece ver)
      .bu ld()
  }

  val manhattanKVNtab toryStoreEndpo nt: ManhattanKVEndpo nt = {
    val mhCl ent = ManhattanKVCl ent("fr gate_ntab", O ga.w lyNa , manhattanCl entMtlsParams)
    ManhattanKVEndpo ntBu lder(mhCl ent)
      .defaultGuarantee(Guarantee.SoftDcRead Wr es)
      .defaultMaxT  out(5.seconds)
      .maxRetryCount(3)
      .statsRece ver(statsRece ver)
      .bu ld()
  }

  val nTab toryStore: ReadableWr ableStore[(Long, Str ng), Gener cNot f cat onOverr deKey] = {
    ObservedReadableWr ableStore(
      NTab toryStore(manhattanKVNtab toryStoreEndpo nt, "fr gate_ntab_gener c_not f_ tory")
    )(statsRece ver.scope("NTab toryStore"))
  }

  overr de lazy val ocfFat gueStore: ReadableStore[OCF toryStoreKey, Fat gueFlowEnroll nt] =
    new OCFPrompt toryStore(
      manhattanApp d = "fr gate_pushserv ce_ocf_fat gue_store",
      dataset = "fat gue_v1",
      manhattanCl entMtlsParams
    )

  def  toryStore: PushServ ce toryStore

  def ema l toryStore: PushServ ce toryStore

  def loggedOut toryStore: PushServ ce toryStore

  overr de val hydratedLabeledPushRecsStore: ReadableStore[User toryKey, User toryValue] = {
    val labeled tory mcac Cl ent = {
       mcac Store. mcac dCl ent(
        na  = Cl entNa (" tory- mcac "),
        dest = ZkEndPo nt(fr gate toryCac Dest),
        statsRece ver = statsRece ver,
        t  out = 2.seconds,
        serv ce dent f er = serv ce dent f er
      )
    }

     mpl c  val keyCodec = CompactScalaCodec(User toryKey)
     mpl c  val valueCodec = CompactScalaCodec(User toryValue)
    val dataset: Dataset[User toryKey, User toryValue] =
      Dataset(
        "",
        "fr gate_data_p pel ne_pushserv ce",
        "labeled_push_recs_aggregated_hydrated",
        At na
      )
    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = ObservedReadableStore(bu ldManhattanStore(dataset))(
        statsRece ver.scope("Uncac dHydratedLabeledPushRecsStore")
      ),
      cac Cl ent = labeled tory mcac Cl ent,
      ttl = 6.h s
    )(
      value nject on = valueCodec,
      statsRece ver = statsRece ver.scope("HydratedLabeledPushRecsStore"),
      keyToStr ng = {
        case User toryKey.User d(user d) => s"HLPRS/$user d"
        case unknownKey =>
          throw new  llegalArgu ntExcept on(s"Unknown user toryStore cac  key $unknownKey")
      }
    )
  }

  overr de val realT  Cl entEventStore: RealT  Cl entEventStore = {
    val cl ent = ManhattanKVCl ent(
      "fr gate_eventstream",
      "/s/manhattan/o ga.nat ve-thr ft",
      manhattanCl entMtlsParams
    )
    val endpo nt =
      ManhattanKVEndpo ntBu lder(cl ent)
        .defaultGuarantee(Guarantee.SoftDcRead Wr es)
        .defaultMaxT  out(3.seconds)
        .statsRece ver(statsRece ver)
        .bu ld()

    ManhattanRealT  Cl entEventStore(endpo nt, "realt  _cl ent_events", statsRece ver, None)
  }

  overr de val onl neUser toryStore: ReadableStore[Onl neUser toryKey, User toryValue] = {
    Onl neUser toryStore(realT  Cl entEventStore)
  }

  overr de val user d aRepresentat onStore = User d aRepresentat onStore(
    "user_ d a_representat on",
    "user_ d a_representat on_dataset",
    manhattanCl entMtlsParams
  )

  overr de val producer d aRepresentat onStore = Observed mcac dReadableStore.fromCac Cl ent(
    back ngStore = User d aRepresentat onStore(
      "user_ d a_representat on",
      "producer_ d a_representat on_dataset",
      manhattanCl entMtlsParams
    )(statsRece ver.scope("Uncac dProducer d aRepStore")),
    cac Cl ent = pushServ ceCac Cl ent,
    ttl = 4.h s
  )(
    value nject on = B naryScalaCodec(User d aRepresentat on),
    keyToStr ng = { k: Long => s"Producer d aRepStore/$k" },
    statsRece ver.scope("Producer d aRepStore")
  )

  overr de val mrUserStatePred ct onStore = {
    StratoFetchableStore.w hUn V ew[Long, MRUserHmmState](
      stratoCl ent,
      "fr gate/mag crecs/mrUserStatePred ct on.User")
  }

  overr de val userHTLLastV s Store =
    UserHTLLastV s ReadableStore(
      "pushserv ce_htl_user_sess on",
      "tls_user_sess on_store",
      statsRece ver.scope("userHTLLastV s Store"),
      manhattanCl entMtlsParams
    )

  val crM xerCl ent: CrM xer. thodPerEndpo nt = new CrM xer.F nagledCl ent(
    readOnlyThr ftServ ce(
      "cr-m xer",
      "/s/cr-m xer/cr-m xer-plus",
      statsRece ver,
      pushserv ceThr ftCl ent d,
      requestT  out = 5.seconds,
      mTLSServ ce dent f er = So (serv ce dent f er)
    ),
    cl entParam = R chCl entParam(serv ceNa  = "cr-m xer")
  )

  val crM xerStore = CrM xerT etStore(crM xerCl ent)(statsRece ver.scope("CrM xerT etStore"))

  val contentM xerCl ent: ContentM xer. thodPerEndpo nt = new ContentM xer.F nagledCl ent(
    readOnlyThr ftServ ce(
      "content-m xer",
      "/s/corg -shared/content-m xer",
      statsRece ver,
      pushserv ceThr ftCl ent d,
      requestT  out = 5.seconds,
      mTLSServ ce dent f er = So (serv ce dent f er)
    ),
    cl entParam = R chCl entParam(serv ceNa  = "content-m xer")
  )

  val exploreRankerCl ent: ExploreRanker. thodPerEndpo nt =
    new ExploreRanker.F nagledCl ent(
      readOnlyThr ftServ ce(
        "explore-ranker",
        "/s/explore-ranker/explore-ranker",
        statsRece ver,
        pushserv ceThr ftCl ent d,
        requestT  out = 5.seconds,
        mTLSServ ce dent f er = So (serv ce dent f er)
      ),
      cl entParam = R chCl entParam(serv ceNa  = "explore-ranker")
    )

  val contentM xerStore = {
    ObservedReadableStore(ContentM xerStore(contentM xerCl ent))(
      statsRece ver.scope("ContentM xerStore"))
  }

  val exploreRankerStore = {
    ObservedReadableStore(ExploreRankerStore(exploreRankerCl ent))(
      statsRece ver.scope("ExploreRankerStore")
    )
  }

  val g zmoduckUtcOffsetStore = ObservedReadableStore(
    G zmoduckUserUtcOffsetStore.fromUserStore(safeUserStore)
  )(statsRece ver.scope("G zmoUserUtcOffsetStore"))

  overr de val userUtcOffsetStore =
    UtcOffsetStore
      .make mcac dUtcOffsetStore(
        g zmoduckUtcOffsetStore,
        pushServ ceCoreSvcsCac Cl ent,
        ReadableStore.empty,
        manhattanStarbuckApp d,
        manhattanCl entMtlsParams
      )(statsRece ver)
      .mapValues(Durat on.fromSeconds)

  overr de val cac dT etyP eStoreV2 = {
    val getT etOpt ons = So (
      GetT etOpt ons(
        safetyLevel = So (SafetyLevel.Mag cRecsV2),
         ncludeRet etCount = true,
         ncludeReplyCount = true,
         ncludeFavor eCount = true,
         ncludeQuotedT et = true,
        add  onalF eld ds = Seq(V s bleTextRangeF eld. d)
      )
    )
    bu ldCac dT etyP eStore(getT etOpt ons, "tp_v2")
  }

  overr de val cac dT etyP eStoreV2NoVF = {
    val getT etOpt ons = So (
      GetT etOpt ons(
        safetyLevel = So (SafetyLevel.F lterDefault),
         ncludeRet etCount = true,
         ncludeReplyCount = true,
         ncludeFavor eCount = true,
         ncludeQuotedT et = true,
        add  onalF eld ds = Seq(V s bleTextRangeF eld. d),
      )
    )
    bu ldCac dT etyP eStore(getT etOpt ons, "tp_v2_noVF")
  }

  overr de val safeCac dT etyP eStoreV2 = {
    val getT etOpt ons = So (
      GetT etOpt ons(
        safetyLevel = So (SafetyLevel.Mag cRecsAggress veV2),
         ncludeRet etCount = true,
         ncludeReplyCount = true,
         ncludeFavor eCount = true,
         ncludeQuotedT et = true,
        add  onalF eld ds = Seq(V s bleTextRangeF eld. d)
      )
    )
    bu ldCac dT etyP eStore(getT etOpt ons, "sftp_v2")
  }

  overr de val userT etT etyP eStore: ReadableStore[UserT et, T etyP eResult] = {
    val getT etOpt ons = So (
      GetT etOpt ons(
        safetyLevel = So (SafetyLevel.Mag cRecsV2),
         ncludeRet etCount = true,
         ncludeReplyCount = true,
         ncludeFavor eCount = true,
         ncludeQuotedT et = true,
        add  onalF eld ds = Seq(V s bleTextRangeF eld. d)
      )
    )
    T etyP eStore.bu ldUserT etStore(
      cl ent = t etyP eCl ent,
      opt ons = getT etOpt ons
    )
  }

  overr de val safeUserT etT etyP eStore: ReadableStore[UserT et, T etyP eResult] = {
    val getT etOpt ons = So (
      GetT etOpt ons(
        safetyLevel = So (SafetyLevel.Mag cRecsAggress veV2),
         ncludeRet etCount = true,
         ncludeReplyCount = true,
         ncludeFavor eCount = true,
         ncludeQuotedT et = true,
        add  onalF eld ds = Seq(V s bleTextRangeF eld. d)
      )
    )
    T etyP eStore.bu ldUserT etStore(
      cl ent = t etyP eCl ent,
      opt ons = getT etOpt ons
    )
  }

  overr de val t etContentFeatureCac Store: ReadableStore[Long, Thr ftDataRecord] = {
    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = T etContentFeatureReadableStore(stratoCl ent),
      cac Cl ent = poptart mpress onsCac Cl ent,
      ttl = 12.h s
    )(
      value nject on = B naryScalaCodec(Thr ftDataRecord),
      statsRece ver = statsRece ver.scope("T etContentFeaturesCac Store"),
      keyToStr ng = { k: Long => s"tcf/$k" }
    )
  }

  lazy val t etTranslat onStore: ReadableStore[
    T etTranslat onStore.Key,
    T etTranslat onStore.Value
  ] = {
    val  sT etTranslatableStore =
      StratoFetchableStore
        .w hUn V ew[ sT etTranslatableCl entColumn.Key, Boolean](
          fetc r = new  sT etTranslatableCl entColumn(stratoCl ent).fetc r
        )

    val translateT etStore =
      StratoFetchableStore
        .w hUn V ew[Mach neTranslateT etCl entColumn.Key, Mach neTranslat onResponse](
          fetc r = new Mach neTranslateT etCl entColumn(stratoCl ent).fetc r
        )

    ObservedReadableStore(
      T etTranslat onStore(translateT etStore,  sT etTranslatableStore, statsRece ver)
    )(statsRece ver.scope("t etTranslat onStore"))
  }

  val scarecrowCl ent = new ScarecrowServ ce.F nagledCl ent(
    readOnlyThr ftServ ce(
      "",
      "/s/abuse/scarecrow",
      statsRece ver,
      not f erThr ftCl ent d,
      requestT  out = 5.second,
      mTLSServ ce dent f er = So (serv ce dent f er)
    ),
    cl entParam = R chCl entParam(serv ceNa  = "")
  )

  // Sett ng up scarecrow store
  overr de val scarecrowC ckEventStore = {
    ScarecrowC ckEventStore(scarecrowCl ent)
  }

  // sett ng up t  perspect ve store
  overr de val userT etPerspect veStore = {
    val serv ce = new Dynam cRequest terF lter(
      tunableMap(PushServ ceTunableKeys.T etPerspect veStoreQpsL m ),
      RateL m erGenerator.asTuple(_, shardParams.numShards, 40),
      PushQPSL m Constants.Perspect veStoreQPS)(t  r)
      .andT n(
        readOnlyThr ftServ ce(
          "t etyp e_perspect ve_serv ce",
          "/s/t etyp e/t etyp e",
          statsRece ver,
          not f erThr ftCl ent d,
          mTLSServ ce dent f er = So (serv ce dent f er)
        )
      )

    val cl ent = new T etServ ce.F nagledCl ent(
      serv ce,
      cl entParam = R chCl entParam(serv ceNa  = "t etyp e_perspect ve_cl ent"))
    ObservedReadableStore(
      Perspect veReadableStore(cl ent)
    )(statsRece ver.scope("T etPerspect veStore"))
  }

  //user country code store, used  n RecsW h ldContentPred cate - wrapped by  mcac  based cac 
  overr de val userCountryStore =
    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = ObservedReadableStore(
        UserCountryStore( tastoreLocat onApp d, manhattanCl entMtlsParams)
      )(statsRece ver.scope("userCountryStore")),
      cac Cl ent = pushServ ceCac Cl ent,
      ttl = 12.h s
    )(
      value nject on = B naryScalaCodec(Locat on),
      statsRece ver = statsRece ver.scope("UserCountryStore"),
      keyToStr ng = { k: Long => s"UserCountryStore/$k" }
    )

  overr de val aud oSpacePart c pantsStore: ReadableStore[Str ng, Part c pants] = {
    val store = StratoFetchableStore
      .DefaultStratoFetchableStore(
        fetc r = new Part c pantsOnAud oSpaceCl entColumn(stratoCl ent).fetc r
      ).composeKeyMapp ng[Str ng](broadcast d =>
        (broadcast d, Aud oSpacesLookupContext(forUser d = None)))

    ObservedCac dReadableStore
      .from(
        store = bu ldStore(store, "Aud oSpacePart c pantsStore"),
        ttl = 20.seconds,
        maxKeys = 200,
        cac Na  = "Aud oSpacePart c pantsStore",
        w ndowS ze = 200
      )

  }

  overr de val top cSoc alProofServ ceStore: ReadableStore[
    Top cSoc alProofRequest,
    Top cSoc alProofResponse
  ] = {
    StratoFetchableStore.w hUn V ew[Top cSoc alProofRequest, Top cSoc alProofResponse](
      stratoCl ent,
      "top c-s gnals/tsp/top c-soc al-proof")
  }

  overr de val spaceDev ceFollowStore: ReadableStore[S ceDestUserRequest, Boolean] = {
    StratoFetchableStore.w hUn V ew(
      fetc r = new SpaceDev ceFollow ngCl entColumn(stratoCl ent).fetc r
    )
  }

  overr de val aud oSpaceStore: ReadableStore[Str ng, Aud oSpace] = {
    val store = StratoFetchableStore
      .DefaultStratoFetchableStore(
        fetc r = new CoreOnAud oSpaceCl entColumn(stratoCl ent).fetc r
      ).composeKeyMapp ng[Str ng] { broadcast d =>
        (broadcast d, Aud oSpacesLookupContext(forUser d = None))
      }

    ObservedCac dReadableStore
      .from(
        store = bu ldStore(store, "Aud oSpaceV s b l yStore"),
        ttl = 1.m nute,
        maxKeys = 5000,
        cac Na  = "Aud oSpaceV s b l yStore",
        w ndowS ze = 10000L)
  }

  overr de val userLanguagesStore = UserLanguagesStore(
    manhattan tastoreApp d,
    manhattanCl entMtlsParams,
    statsRece ver.scope("user_languages_store")
  )

  val tflockCl ent: TFlockCl ent = new TFlockCl ent(
    new FlockDB.F nagledCl ent(
      readOnlyThr ftServ ce(
        "tflockCl ent",
        "/s/tflock/tflock",
        statsRece ver,
        pushserv ceThr ftCl ent d,
        mTLSServ ce dent f er = So (serv ce dent f er)
      ),
      serv ceNa  = "tflock",
      stats = statsRece ver
    ),
    defaultPageS ze = 1000
  )

  val rawFlockCl ent = Thr ftMux.cl ent
    .w hCl ent d(pushserv ceThr ftCl ent d)
    .w hMutualTls(serv ce dent f er)
    .bu ld[FlockDB. thodPerEndpo nt]("/s/flock/flock")

  val flockCl ent: FlockCl ent = new FlockCl ent(
    rawFlockCl ent,
    defaultPageS ze = 100
  )

  overr de val recentFollowsStore: FlockFollowStore = {
    val dStats = statsRece ver.scope("FlockRecentFollowsStore")
    FlockFollowStore(flockCl ent, dStats)
  }

  def not f cat onServ ceCl ent: Not f cat onServ ce$F nagleCl ent

  def not f cat onServ ceSend(
    target: Target,
    request: CreateGener cNot f cat onRequest
  ): Future[CreateGener cNot f cat onResponse]

  def not f cat onServ ceDelete(
    request: DeleteGener cNot f cat onRequest
  ): Future[Un ]

  def not f cat onServ ceDeleteT  l ne(
    request: DeleteCurrentT  l neForUserRequest
  ): Future[Un ]

  overr de val not f cat onServ ceSender: ReadableStore[
    Not f cat onServ ceRequest,
    CreateGener cNot f cat onResponse
  ] = {
    new Not f cat onServ ceSender(
      not f cat onServ ceSend,
      PushParams.EnableWr esToNot f cat onServ ceParam,
      PushParams.EnableWr esToNot f cat onServ ceForAllEmployeesParam,
      PushParams.EnableWr esToNot f cat onServ ceForEveryoneParam
    )
  }

  val eventRecosServ ceCl ent = {
    val dest = "/s/events-recos/events-recos-serv ce"
    new EventsRecosServ ce.F nagledCl ent(
      readOnlyThr ftServ ce(
        "EventRecosServ ce",
        dest,
        statsRece ver,
        pushserv ceThr ftCl ent d,
        mTLSServ ce dent f er = So (serv ce dent f er)
      ),
      cl entParam = R chCl entParam(serv ceNa  = "EventRecosServ ce")
    )
  }

  lazy val recom ndedTrendsCand dateS ce = Recom ndedTrendsCand dateS ce(
    TrendsRecom ndat onStore(eventRecosServ ceCl ent, statsRece ver))

  overr de val softUserGeoLocat onStore: ReadableStore[Long, GeoLocat on] =
    StratoFetchableStore.w hUn V ew[Long, GeoLocat on](fetc r =
      new FrequentSoftUserLocat onCl entColumn(stratoCl ent).fetc r)

  lazy val cand dateS ceGenerator = new PushCand dateS ceGenerator(
    earlyb rdCand dateS ce,
    userT etEnt yGraphCand dates,
    cac dT etyP eStoreV2,
    safeCac dT etyP eStoreV2,
    userT etT etyP eStore,
    safeUserT etT etyP eStore,
    cac dT etyP eStoreV2NoVF,
    edgeStore,
     nterestsW hLookupContextStore,
    uttEnt yHydrat onStore,
    geoDuckV2Store,
    topT etsByGeoStore,
    topT etsByGeoV2Vers onedStore,
    ruxT et mpress onsStore,
    recom ndedTrendsCand dateS ce,
    recentT etsByAuthorsStore,
    top cSoc alProofServ ceStore,
    crM xerStore,
    contentM xerStore,
    exploreRankerStore,
    softUserGeoLocat onStore,
    tr pT etCand dateStore,
    popGeoL sts,
     dsStore
  )

  lazy val loCand dateS ceGenerator = new LoggedOutPushCand dateS ceGenerator(
    tr pT etCand dateStore,
    geoDuckV2Store,
    safeCac dT etyP eStoreV2,
    cac dT etyP eStoreV2NoVF,
    cac dT etyP eStoreV2,
    contentM xerStore,
    softUserGeoLocat onStore,
    topT etsByGeoStore,
    topT etsByGeoV2Vers onedStore
  )

  lazy val rfphStatsRecorder = new RFPHStatsRecorder()

  lazy val rfphRestr ctStep = new RFPHRestr ctStep()

  lazy val rfphTakeStepUt l = new RFPHTakeStepUt l()(statsRece ver)

  lazy val rfphPrerankF lter = new RFPHPrerankF lter()(statsRece ver)

  lazy val rfphL ghtRanker = new RFPHL ghtRanker(l ghtRanker, statsRece ver)

  lazy val sendHandlerPred cateUt l = new SendHandlerPred cateUt l()(statsRece ver)

  lazy val ntabSender =
    new NtabSender(
      not f cat onServ ceSender,
      nTab toryStore,
      not f cat onServ ceDelete,
      not f cat onServ ceDeleteT  l ne
    )

  lazy val  b s2Sender = new  b s2Sender(push b sV2Store, t etTranslat onStore, statsRece ver)

  lazy val  toryWr er = new  toryWr er( toryStore, statsRece ver)

  lazy val loggedOut toryWr er = new  toryWr er(loggedOut toryStore, statsRece ver)

  lazy val eventBusWr er = new EventBusWr er(pushSendEventBusPubl s r, statsRece ver)

  lazy val ntabOnlyChannelSelector = new NtabOnlyChannelSelector

  lazy val not f cat onSender =
    new Not f cat onSender(
       b s2Sender,
      ntabSender,
      statsRece ver,
      not f cat onScr be
    )

  lazy val cand dateNot f er =
    new Cand dateNot f er(
      not f cat onSender,
      casLock = casLock,
       toryWr er =  toryWr er,
      eventBusWr er = eventBusWr er,
      ntabOnlyChannelSelector = ntabOnlyChannelSelector
    )(statsRece ver)

  lazy val loggedOutCand dateNot f er = new Cand dateNot f er(
    not f cat onSender,
    casLock = casLock,
     toryWr er = loggedOut toryWr er,
    eventBusWr er = null,
    ntabOnlyChannelSelector = ntabOnlyChannelSelector
  )(statsRece ver)

  lazy val rfphNot f er =
    new RefreshForPushNot f er(rfphStatsRecorder, cand dateNot f er)(statsRece ver)

  lazy val loRfphNot f er =
    new LoggedOutRefreshForPushNot f er(rfphStatsRecorder, loggedOutCand dateNot f er)(
      statsRece ver)

  lazy val rfphRanker = {
    val randomRanker = RandomRanker[Target, PushCand date]()
    val subscr pt onCreatorRanker =
      new Subscr pt onCreatorRanker(superFollowEl g b l yUserStore, statsRece ver)
    new RFPHRanker(
      randomRanker,
        ghtedOpenOrNtabCl ckModelScorer,
      subscr pt onCreatorRanker,
      user althS gnalStore,
      producer d aRepresentat onStore,
      statsRece ver
    )
  }

  lazy val rfphFeatureHydrator = new RFPHFeatureHydrator(featureHydrator)
  lazy val loggedOutRFPHRanker = new LoggedOutRanker(cac dT etyP eStoreV2, statsRece ver)

  overr de val userFeaturesStore: ReadableStore[Long, UserFeatures] = {
     mpl c  val valueCodec = new B naryScalaCodec(UserFeatures)
    val dataset: Dataset[Long, UserFeatures] =
      Dataset(
        "",
        "user_features_pushserv ce_apollo",
        "recom ndat ons_user_features_apollo",
        Apollo)

    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = ObservedReadableStore(bu ldManhattanStore(dataset))(
        statsRece ver.scope("Uncac dUserFeaturesStore")
      ),
      cac Cl ent = pushServ ceCac Cl ent,
      ttl = 24.h s
    )(
      value nject on = valueCodec,
      statsRece ver = statsRece ver.scope("UserFeaturesStore"),
      keyToStr ng = { k: Long => s"ufts/$k" }
    )
  }

  overr de def htlScoreStore(user d: Long): ReadableStore[Long, ScoredT et] = {
    val fetc r = new T  l neScorerT etScoresV1Cl entColumn(stratoCl ent).fetc r
    val htlStore = bu ldStore(
      StratoFetchableStore.w hV ew[Long, T  l neScorerScoreV ew, ScoredT et](
        fetc r,
        T  l neScorerScoreV ew(So (user d))
      ),
      "htlScoreStore"
    )
    htlStore
  }

  overr de val userTarget ngPropertyStore: ReadableStore[Long, UserTarget ngProperty] = {
    val na  = "userTarget ngPropertyStore"
    val store = StratoFetchableStore
      .w hUn V ew(new Target ngPropertyOnUserCl entColumn(stratoCl ent).fetc r)
    bu ldStore(store, na )
  }

  overr de val t  l nesUserSess onStore: ReadableStore[Long, UserSess on] = {
     mpl c  val valueCodec = new CompactScalaCodec(UserSess on)
    val dataset: Dataset[Long, UserSess on] = Dataset[Long, UserSess on](
      "",
      "fr gate_realgraph",
      "real_graph_user_features",
      Apollo
    )

    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = ObservedReadableStore(bu ldManhattanStore(dataset))(
        statsRece ver.scope("Uncac dT  l nesUserSess onStore")
      ),
      cac Cl ent = pushServ ceCac Cl ent,
      ttl = 6.h s
    )(
      value nject on = valueCodec,
      statsRece ver = statsRece ver.scope("t  l nesUserSess onStore"),
      keyToStr ng = { k: Long => s"tluss/$k" }
    )
  }

  lazy val recentT etsFromTflockStore: ReadableStore[Long, Seq[Long]] =
    ObservedReadableStore(
      RecentT etsByAuthorsStore.us ngRecentT etsConf g(
        tflockCl ent,
        RecentT etsConf g(maxResults = 1, maxAge = 3.days)
      )
    )(statsRece ver.scope("RecentT etsFromTflockStore"))

  lazy val recentT etsByAuthorsStore: ReadableStore[RecentT etsQuery, Seq[Seq[Long]]] =
    ObservedReadableStore(
      RecentT etsByAuthorsStore(tflockCl ent)
    )(statsRece ver.scope("RecentT etsByAuthorsStore"))

  val jobConf g = PopGeo nterestProv der
    .getPopularT etsJobConf g(
       nterestDeployConf g(
        App d("PopularT etsBy nterestProd"),
        Cluster.ATLA,
        Env.Prod,
        serv ce dent f er,
        manhattanCl entMtlsParams
      ))
    .w hManhattanApp d("fr gate_pop_by_geo_t ets")

  overr de val topT etsByGeoStore = TopT etsStore.w h mCac (
    jobConf g,
    pushServ ceCac Cl ent,
    10.seconds
  )(statsRece ver)

  overr de val topT etsByGeoV2Vers onedStore: ReadableStore[Str ng, PopT ets nPlace] = {
    StratoFetchableStore.w hUn V ew[Str ng, PopT ets nPlace](
      stratoCl ent,
      "recom ndat ons/popgeo/popGeoT etsVers oned")
  }

  overr de lazy val pushcapDynam cPred ct onStore: ReadableStore[Long, PushcapUser tory] = {
    StratoFetchableStore.w hUn V ew[Long, PushcapUser tory](
      stratoCl ent,
      "fr gate/mag crecs/pushcapDynam cPred ct on.User")
  }

  overr de val t etAuthorLocat onFeatureBu lder =
    UserLocat onFeatureBu lder(So ("T etAuthor"))
      .w hStats()

  overr de val t etAuthorLocat onFeatureBu lderBy d =
    UserLocat onFeatureBu lderBy d(
      userCountryStore,
      t etAuthorLocat onFeatureBu lder
    ).w hStats()

  overr de val soc alContextAct onsFeatureBu lder =
    Soc alContextAct onsFeatureBu lder().w hStats()

  overr de val t etContentFeatureBu lder =
    T etContentFeatureBu lder(t etContentFeatureCac Store).w hStats()

  overr de val t etAuthorRecentRealGraphFeatureBu lder =
    RecentRealGraphFeatureBu lder(
      stratoCl ent,
      UserAuthorEnt y,
      TargetUserEnt y,
      T etAuthorEnt y,
      T etAuthorRecentRealGraphFeatures(statsRece ver.scope("T etAuthorRecentRealGraphFeatures"))
    ).w hStats()

  overr de val soc alContextRecentRealGraphFeatureBu lder =
    Soc alContextRecentRealGraphFeatureBu lder(
      RecentRealGraphFeatureBu lder(
        stratoCl ent,
        TargetUserSoc alContextEnt y,
        TargetUserEnt y,
        Soc alContextEnt y,
        Soc alContextRecentRealGraphFeatures(
          statsRece ver.scope("Soc alContextRecentRealGraphFeatures"))
      )(statsRece ver
        .scope("Soc alContextRecentRealGraphFeatureBu lder").scope("RecentRealGraphFeatureBu lder"))
    ).w hStats()

  overr de val t etSoc alProofFeatureBu lder =
    T etSoc alProofFeatureBu lder(So ("TargetUser")).w hStats()

  overr de val targetUserFullRealGraphFeatureBu lder =
    TargetFullRealGraphFeatureBu lder(So ("TargetUser")).w hStats()

  overr de val postProcess ngFeatureBu lder: PostProcess ngFeatureBu lder =
    PostProcess ngFeatureBu lder()

  overr de val mrOffl neUserCand dateSparseAggregatesFeatureBu lder =
    MrOffl neUserCand dateSparseAggregatesFeatureBu lder(stratoCl ent, featureStoreUt l).w hStats()

  overr de val mrOffl neUserAggregatesFeatureBu lder =
    MrOffl neUserAggregatesFeatureBu lder(stratoCl ent, featureStoreUt l).w hStats()

  overr de val mrOffl neUserCand dateAggregatesFeatureBu lder =
    MrOffl neUserCand dateAggregatesFeatureBu lder(stratoCl ent, featureStoreUt l).w hStats()

  overr de val t etAnnotat onsFeatureBu lder =
    T etAnnotat onsFeatureBu lder(stratoCl ent).w hStats()

  overr de val targetUser d aRepresentat onFeatureBu lder =
    User d aRepresentat onFeatureBu lder(user d aRepresentat onStore).w hStats()

  overr de val targetLevelFeatureBu lder =
    TargetLevelFeatureBu lder(featureStoreUt l, targetLevelFeaturesConf g).w hStats()

  overr de val cand dateLevelFeatureBu lder =
    Cand dateLevelFeatureBu lder(featureStoreUt l).w hStats()

  overr de lazy val targetFeatureHydrator = RelevanceTargetFeatureHydrator(
    targetUserFullRealGraphFeatureBu lder,
    postProcess ngFeatureBu lder,
    targetUser d aRepresentat onFeatureBu lder,
    targetLevelFeatureBu lder
  )

  overr de lazy val featureHydrator =
    FeatureHydrator(targetFeatureHydrator, cand dateFeatureHydrator)

  val pushServ ceL ghtRankerConf g: L ghtRankerConf g = new L ghtRankerConf g(
    pushserv ceThr ftCl ent d,
    serv ce dent f er,
    statsRece ver.scope("l ghtRanker"),
    deepb rdv2Pred ct onServ ceDest,
    "Deepb rdV2Pred ct onServ ce"
  )
  val l ghtRanker: Mag cRecsServeDataRecordL ghtRanker =
    pushServ ceL ghtRankerConf g.l ghtRanker

  overr de val t et mpress onStore: ReadableStore[Long, Seq[Long]] = {
    val na  = "htl_ mpress on_store"
    val store = bu ldStore(
      HtlT et mpress onStore.createStoreW hT et ds(
        requestT  out = 6.seconds,
        label = "htl_t et_ mpress ons",
        serv ce dent f er = serv ce dent f er,
        statsRece ver = statsRece ver
      ),
      na 
    )
    val numT etsReturned =
      statsRece ver.scope(na ).stat("num_t ets_returned_per_user")
    new Transfor dReadableStore(store)((user d: Long, t et ds: Seq[Long]) => {
      numT etsReturned.add(t et ds.s ze)
      Future.value(So (t et ds))
    })
  }

  val ruxT et mpress onsStore = new T et mpress onsStore(stratoCl ent)

  overr de val strongT esStore: ReadableStore[Long, STPResult] = {
     mpl c  val valueCodec = new B naryScalaCodec(STPResult)
    val strongT eScor ngDataset: Dataset[Long, STPResult] =
      Dataset("", "fr gate_stp", "stp_result_rerank", At na)
    bu ldManhattanStore(strongT eScor ngDataset)
  }

  overr de lazy val earlyb rdFeatureStore = ObservedReadableStore(
    Earlyb rdFeatureStore(
      cl ent d = pushserv ceThr ftCl ent d.na ,
      earlyb rdSearchStore = earlyb rdSearchStore
    )
  )(statsRece ver.scope("Earlyb rdFeatureStore"))

  overr de lazy val earlyb rdFeatureBu lder = Earlyb rdFeatureBu lder(earlyb rdFeatureStore)

  overr de lazy val earlyb rdSearchStore = {
    val earlyb rdCl entNa : Str ng = "earlyb rd"
    val earlyb rdSearchStoreNa : Str ng = "Earlyb rdSearchStore"

    val earlyb rdCl ent = new Earlyb rdServ ce.F nagledCl ent(
      readOnlyThr ftServ ce(
        earlyb rdCl entNa ,
        earlyb rdSearchDest,
        statsRece ver,
        pushserv ceThr ftCl ent d,
        tr es = 1,
        requestT  out = 3.seconds,
        mTLSServ ce dent f er = So (serv ce dent f er)
      ),
      cl entParam = R chCl entParam(protocolFactory = new TCompactProtocol.Factory)
    )

    ObservedReadableStore(
      Earlyb rdSearchStore(earlyb rdCl ent)(statsRece ver.scope(earlyb rdSearchStoreNa ))
    )(statsRece ver.scope(earlyb rdSearchStoreNa ))
  }

  overr de lazy val earlyb rdCand dateS ce: Earlyb rdCand dateS ce = Earlyb rdCand dateS ce(
    cl ent d = pushserv ceThr ftCl ent d.na ,
    earlyb rdSearchStore = earlyb rdSearchStore
  )

  overr de val realGraphScoresTop500 nStore: RealGraphScoresTop500 nStore = {
    val stratoRealGraph nStore =
      StratoFetchableStore
        .w hUn V ew[Long, Cand dateSeq](
          stratoCl ent,
          "fr gate/mag crecs/fanoutCo 500pRealGraphV2")

    RealGraphScoresTop500 nStore(
      Observed mcac dReadableStore.fromCac Cl ent(
        back ngStore = stratoRealGraph nStore,
        cac Cl ent = ent yGraphCac Cl ent,
        ttl = 24.h s
      )(
        value nject on = B naryScalaCodec(Cand dateSeq),
        statsRece ver = statsRece ver.scope("Cac dRealGraphScoresTop500 nStore"),
        keyToStr ng = { k: Long => s"500p_test/$k" }
      )
    )
  }

  overr de val t etEnt yGraphStore = {
    val t etEnt yGraphCl ent = new UserT etEnt yGraph.F nagledCl ent(
      F nagle.readOnlyThr ftServ ce(
        "user_t et_ent y_graph",
        userT etEnt yGraphDest,
        statsRece ver,
        pushserv ceThr ftCl ent d,
        requestT  out = 5.seconds,
        mTLSServ ce dent f er = So (serv ce dent f er)
      )
    )
    ObservedReadableStore(
      Recom ndedT etEnt  esStore(
        t etEnt yGraphCl ent,
        statsRece ver.scope("Recom ndedT etEnt  esStore")
      )
    )(statsRece ver.scope("Recom ndedT etEnt  esStore"))
  }

  overr de val userUserGraphStore = {
    val userUserGraphCl ent = new UserUserGraph.F nagledCl ent(
      F nagle.readOnlyThr ftServ ce(
        "user_user_graph",
        userUserGraphDest,
        statsRece ver,
        pushserv ceThr ftCl ent d,
        requestT  out = 5.seconds,
        mTLSServ ce dent f er = So (serv ce dent f er)
      ),
      cl entParam = R chCl entParam(serv ceNa  = "user_user_graph")
    )
    ObservedReadableStore(
      UserUserGraphStore(userUserGraphCl ent, statsRece ver.scope("UserUserGraphStore"))
    )(statsRece ver.scope("UserUserGraphStore"))
  }

  overr de val ntabCaretFeedbackStore: ReadableStore[Gener cNot f cat onsFeedbackRequest, Seq[
    CaretFeedbackDeta ls
  ]] = {
    val cl ent = ManhattanKVCl ent(
      "pushserv ce_ntab_caret_feedback_o ga",
      O ga.w lyNa ,
      manhattanCl entMtlsParams
    )
    val endpo nt = ManhattanKVEndpo ntBu lder(cl ent)
      .defaultGuarantee(Guarantee.SoftDcRead Wr es)
      .defaultMaxT  out(3.seconds)
      .maxRetryCount(2)
      .statsRece ver(statsRece ver)
      .bu ld()

    val feedbackS gnalManhattanCl ent =
      FeedbackS gnalManhattanCl ent(endpo nt, statsRece ver.scope("FeedbackS gnalManhattanCl ent"))
    NtabCaretFeedbackStore(feedbackS gnalManhattanCl ent)
  }

  overr de val gener cFeedbackStore: ReadableStore[FeedbackRequest, Seq[
    FeedbackPromptValue
  ]] = {
    FeedbackStore(
      Gener cFeedbackStoreBu lder.bu ld(
        manhattanKVCl entApp d = "fr gate_pushserv ce_ntabfeedback_prompt",
        env ron nt = Not fEnv ron nt.apply(serv ce dent f er.env ron nt),
        svc dent f er = serv ce dent f er,
        statsRece ver = statsRece ver
      ))
  }

  overr de val gener cNot f cat onFeedbackStore: Gener cFeedbackStore = {

    Gener cFeedbackStoreBu lder.bu ld(
      manhattanKVCl entApp d = "fr gate_pushserv ce_ntabfeedback_prompt",
      env ron nt = Not fEnv ron nt.apply(serv ce dent f er.env ron nt),
      svc dent f er = serv ce dent f er,
      statsRece ver = statsRece ver
    )
  }

  overr de val earlyb rdSearchDest = "/s/earlyb rd-root-superroot/root-superroot"

  // low latency as compared to default `semant cCore tadataCl ent`
  pr vate val lowLatencySemant cCore tadataCl ent:  tadataServ ce. thodPerEndpo nt =
    new  tadataServ ce.F nagledCl ent(
      F nagle.readOnlyThr ftServ ce(
        na  = "semant c_core_ tadata_serv ce",
        dest = "/s/esc rb rd/ tadataserv ce",
        statsRece ver = statsRece ver,
        thr ftCl ent d = pushserv ceThr ftCl ent d,
        tr es = 2, // total number of tr es. number of retr es = tr es - 1
        requestT  out = 2.seconds,
        mTLSServ ce dent f er = So (serv ce dent f er)
      )
    )

  pr vate val semant cCore tadataSt chCl ent = new  tadataSt chCl ent(
    lowLatencySemant cCore tadataCl ent
  )

  overr de val semant cCore gadataStore: ReadableStore[Semant cEnt yForQuery, Ent y gadata] = {
    val na  = "semant c_core_ gadata_store_cac d"
    val store =  taDataReadableStore.get gadataReadableStore(
       tadataSt chCl ent = semant cCore tadataSt chCl ent,
      typed tadataDoma ns = So (Set(Doma ns.EventsEnt yServ ce))
    )
    ObservedCac dReadableStore
      .from(
        store = ObservedReadableStore(store)(
          statsRece ver
            .scope("store")
            .scope("semant c_core_ gadata_store")
        ),
        ttl = 1.h ,
        maxKeys = 1000,
        cac Na  = "semant c_core_ gadata_cac ",
        w ndowS ze = 10000L
      )(statsRece ver.scope("store", na ))
  }

  overr de val basketballGa ScoreStore: ReadableStore[Qual f ed d, BasketballGa L veUpdate] = {
    StratoFetchableStore.w hUn V ew[Qual f ed d, BasketballGa L veUpdate](
      stratoCl ent,
      "semant cCore/basketballGa Score.Ent y")
  }

  overr de val baseballGa ScoreStore: ReadableStore[Qual f ed d, BaseballGa L veUpdate] = {
    StratoFetchableStore.w hUn V ew[Qual f ed d, BaseballGa L veUpdate](
      stratoCl ent,
      "semant cCore/baseballGa Score.Ent y")
  }

  overr de val cr cketMatchScoreStore: ReadableStore[Qual f ed d, Cr cketMatchL veUpdate] = {
    StratoFetchableStore.w hUn V ew[Qual f ed d, Cr cketMatchL veUpdate](
      stratoCl ent,
      "semant cCore/cr cketMatchScore.Ent y")
  }

  overr de val soccerMatchScoreStore: ReadableStore[Qual f ed d, SoccerMatchL veUpdate] = {
    ObservedCac dReadableStore
      .from(
        store = StratoFetchableStore.w hUn V ew[Qual f ed d, SoccerMatchL veUpdate](
          stratoCl ent,
          "semant cCore/soccerMatchScore.Ent y"),
        ttl = 10.seconds,
        maxKeys = 100,
        cac Na  = "SoccerMatchCac dStore",
        w ndowS ze = 100L
      )(statsRece ver.scope("SoccerMatchCac dStore"))

  }

  overr de val nflGa ScoreStore: ReadableStore[Qual f ed d, NflFootballGa L veUpdate] = {
    ObservedCac dReadableStore
      .from(
        store = StratoFetchableStore.w hUn V ew[Qual f ed d, NflFootballGa L veUpdate](
          stratoCl ent,
          "semant cCore/nflFootballGa Score.Ent y"),
        ttl = 10.seconds,
        maxKeys = 100,
        cac Na  = "NFLMatchCac dStore",
        w ndowS ze = 100L
      )(statsRece ver.scope("NFLMatchCac dStore"))

  }

  overr de val user althS gnalStore: ReadableStore[Long, User althS gnalResponse] = {
    val user althS gnalFetc r =
      stratoCl ent.fetc r[Long, Seq[User althS gnal], User althS gnalResponse](
        "hss/user_s gnals/ap / althS gnals.User"
      )

    val store = bu ldStore(
      StratoFetchableStore.w hV ew[Long, Seq[User althS gnal], User althS gnalResponse](
        user althS gnalFetc r,
        Seq(
          AgathaRecentAbuseStr keDouble,
          AgathaCal bratedNsfwDouble,
          AgathaCseDouble,
          NsfwTextUserScoreDouble,
          NsfwConsu rScoreDouble)),
      "User althS gnalFetc r"
    )
     f (! n mCac Off) {
      ObservedCac dReadableStore
        .from(
          store = ObservedReadableStore(store)(
            statsRece ver.scope("store").scope("user_ alth_model_score_store")),
          ttl = 12.h s,
          maxKeys = 16777215,
          cac Na  = "user_ alth_model_score_store_cac ",
          w ndowS ze = 10000L
        )(statsRece ver.scope("store", "user_ alth_model_score_store_cac d"))
    } else {
      store
    }
  }

  overr de val t et althScoreStore: ReadableStore[T etScor ngRequest, T etScor ngResponse] = {
    val t et althScoreFetc r =
      stratoCl ent.fetc r[T etScor ngRequest, Un , T etScor ngResponse](
        "abuse/detect on/t et althModelScore"
      )

    val store = bu ldStore(
      StratoFetchableStore.w hUn V ew(t et althScoreFetc r),
      "T et althScoreFetc r"
    )

    ObservedCac dReadableStore
      .from(
        store = ObservedReadableStore(store)(
          statsRece ver.scope("store").scope("t et_ alth_model_score_store")),
        ttl = 30.m nutes,
        maxKeys = 1000,
        cac Na  = "t et_ alth_model_score_store_cac ",
        w ndowS ze = 10000L
      )(statsRece ver.scope("store", "t et_ alth_model_score_store_cac d"))
  }

  overr de val appPerm ss onStore: ReadableStore[(Long, (Str ng, Str ng)), AppPerm ss on] = {
    val store = StratoFetchableStore
      .w hUn V ew[(Long, (Str ng, Str ng)), AppPerm ss on](
        stratoCl ent,
        "cl ents/perm ss onsState")
    ObservedCac dReadableStore.from[(Long, (Str ng, Str ng)), AppPerm ss on](
      bu ldStore(store, "mr_app_perm ss on_store"),
      ttl = 30.m nutes,
      maxKeys = 1000,
      cac Na  = "mr_app_perm ss on_store_cac ",
      w ndowS ze = 10000L
    )(statsRece ver.scope("mr_app_perm ss on_store_cac d"))
  }

  def pushSendEventStreamNa : Str ng

  overr de val pushSendEventBusPubl s r = EventBusPubl s rBu lder()
    .cl ent d("fr gate_pushserv ce")
    .streamNa (pushSendEventStreamNa )
    .thr ftStruct(Not f cat onScr be)
    .statsRece ver(statsRece ver.scope("push_send_eventbus"))
    .bu ld()

  overr de lazy val cand dateFeatureHydrator: Cand dateFeatureHydrator =
    Cand dateFeatureHydrator(
      soc alContextAct onsFeatureBu lder = So (soc alContextAct onsFeatureBu lder),
      t etSoc alProofFeatureBu lder = So (t etSoc alProofFeatureBu lder),
      earlyb rdFeatureBu lder = So (earlyb rdFeatureBu lder),
      t etContentFeatureBu lder = So (t etContentFeatureBu lder),
      t etAuthorRecentRealGraphFeatureBu lder = So (t etAuthorRecentRealGraphFeatureBu lder),
      soc alContextRecentRealGraphFeatureBu lder = So (soc alContextRecentRealGraphFeatureBu lder),
      t etAnnotat onsFeatureBu lder = So (t etAnnotat onsFeatureBu lder),
      mrOffl neUserCand dateSparseAggregatesFeatureBu lder =
        So (mrOffl neUserCand dateSparseAggregatesFeatureBu lder),
      cand dateLevelFeatureBu lder = So (cand dateLevelFeatureBu lder)
    )(statsRece ver.scope("push_feature_hydrator"))

  pr vate val cand dateCopyCross =
    new Cand dateCopyExpans on(statsRece ver.scope("refresh_handler/cross"))

  overr de lazy val cand dateHydrator: PushCand dateHydrator =
    PushCand dateHydrator(
      t .soc alGraphServ ceProcessStore,
      safeUserStore,
      l stAP Store,
      cand dateCopyCross)(
      statsRece ver.scope("push_cand date_hydrator"),
        ghtedOpenOrNtabCl ckModelScorer)

  overr de lazy val sendHandlerCand dateHydrator: SendHandlerPushCand dateHydrator =
    SendHandlerPushCand dateHydrator(
      lexServ ceStore,
      fanout tadataStore,
      semant cCore gadataStore,
      safeUserStore,
      s mClusterToEnt yStore,
      aud oSpaceStore,
       nterestsW hLookupContextStore,
      uttEnt yHydrat onStore,
      superFollowCreatorT etCountStore
    )(
      statsRece ver.scope("push_cand date_hydrator"),
        ghtedOpenOrNtabCl ckModelScorer
    )

  def mrRequestScr berNode: Str ng
  def loggedOutMrRequestScr berNode: Str ng

  overr de lazy val conf gParamsBu lder: Conf gParamsBu lder = Conf gParamsBu lder(
    conf g = overr desConf g,
    featureContextBu lder = FeatureContextBu lder(featureSw c s),
    statsRece ver = statsRece ver
  )

  def bu ldStore[K, V](store: ReadableStore[K, V], na : Str ng): ReadableStore[K, V] = {
    ObservedReadableStore(store)(statsRece ver.scope("store").scope(na ))
  }

  def bu ldManhattanStore[K, V](dataset: Dataset[K, V]): ReadableStore[K, V] = {
    val manhattanKVCl entParams = ManhattanKVCl entMtlsParams(
      serv ce dent f er = serv ce dent f er,
      opportun st cTls = Opportun st cTls.Requ red
    )
    ManhattanStore
      .fromDatasetW hMtls[K, V](
        dataset,
        mtlsParams = manhattanKVCl entParams,
        statsRece ver = statsRece ver.scope(dataset.datasetNa ))
  }

  def bu ldCac dT etyP eStore(
    getT etOpt ons: Opt on[GetT etOpt ons],
    keyPref x: Str ng
  ): ReadableStore[Long, T etyP eResult] = {
    def d scardAdd  onal d a nfo(t etyp eResult: T etyP eResult) = {
      val updated d a = t etyp eResult.t et. d a.map {  d aSeq =>
         d aSeq.map {  d a =>  d a.copy(add  onal tadata = None, s zes = N l.toSet) }
      }
      val updatedT et = t etyp eResult.t et.copy( d a = updated d a)
      t etyp eResult.copy(t et = updatedT et)
    }

    val t etyp eStoreW houtAdd  onal d a nfo = T etyP eStore(
      t etyP eCl ent,
      getT etOpt ons,
      transformT etyp eResult = d scardAdd  onal d a nfo
    )(statsRece ver.scope("t etyp e_w hout_add  onal_ d a_ nfo"))

    Observed mcac dReadableStore.fromCac Cl ent(
      back ngStore = t etyp eStoreW houtAdd  onal d a nfo,
      cac Cl ent = pushServ ceCoreSvcsCac Cl ent,
      ttl = 12.h s
    )(
      value nject on = T etyP eResult nject on,
      statsRece ver = statsRece ver.scope("T etyP eStore"),
      keyToStr ng = { k: Long => s"$keyPref x/$k" }
    )
  }

  overr de def  n (): Future[Un ] =
    Cl entReg stry.expAllReg steredCl entsResolved().map { cl ents =>
      log. nfo("Done resolv ng cl ents: " + cl ents.mkStr ng("[", ", ", "]"))
    }

  val  nl neAct onsMhColumn =
    "fr gate/mag crecs/ nl neAct onsMh"

  overr de val  nl neAct on toryStore: ReadableStore[Long, Seq[(Long, Str ng)]] =
    StratoScannableStore
      .w hUn V ew[(Long, Sl ce[Long]), (Long, Long), Str ng](stratoCl ent,  nl neAct onsMhColumn)
      .composeKeyMapp ng[Long] { user d =>
        (user d, Sl ce[Long](from = None, to = None, l m  = None))
      }.mapValues { response =>
        response.map {
          case (key, value) => (key._2, value)
        }
      }

  overr de val tr pT etCand dateStore: ReadableStore[Tr pDoma n, Tr pT ets] = {
    StratoFetchableStore
      .w hUn V ew[Tr pDoma n, Tr pT ets](
        new Tr pT etsA rflowProdCl entColumn(stratoCl ent).fetc r)
  }

  overr de val softUserFollow ngStore: ReadableStore[User, Seq[Long]] = new SoftUserFollow ngStore(
    stratoCl ent)

  overr de val superFollowEl g b l yUserStore: ReadableStore[Long, Boolean] = {
    StratoFetchableStore.w hUn V ew[Long, Boolean](
      stratoCl ent,
      "aud encerewards/aud enceRewardsServ ce/getSuperFollowEl g b l y.User")
  }

  overr de val superFollowCreatorT etCountStore: ReadableStore[User d,  nt] = {
    ObservedCac dReadableStore
      .from(
        store = StratoFetchableStore
          .w hUn V ew[User d,  nt](new CreatorSubscr pt onNumT etsColumn(stratoCl ent).fetc r),
        ttl = 5.m nutes,
        maxKeys = 1000,
        cac Na  = "SuperFollowCreatorT etCountStore",
        w ndowS ze = 10000L
      )(statsRece ver.scope("SuperFollowCreatorT etCountStore"))

  }

  overr de val hasSuperFollow ngRelat onsh pStore: ReadableStore[
    HasSuperFollow ngRelat onsh pRequest,
    Boolean
  ] = {
    StratoFetchableStore.w hUn V ew[HasSuperFollow ngRelat onsh pRequest, Boolean](
      stratoCl ent,
      "aud encerewards/superFollows/hasSuperFollow ngRelat onsh pV2")
  }

  overr de val superFollowAppl cat onStatusStore: ReadableStore[
    (Long, SellerTrack),
    SellerAppl cat onState
  ] = {
    StratoFetchableStore.w hUn V ew[(Long, SellerTrack), SellerAppl cat onState](
      stratoCl ent,
      "per scope/el g b l y/appl cat onStatus")
  }

  def  toryStore mcac Dest: Str ng

  overr de lazy val recent toryCac Cl ent = {
    Recent toryCac Cl ent.bu ld( toryStore mcac Dest, serv ce dent f er, statsRece ver)
  }

  overr de val openAppUserStore: ReadableStore[Long, Boolean] = {
    bu ldStore(OpenAppUserStore(stratoCl ent), "OpenAppUserStore")
  }
}
