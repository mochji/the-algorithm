// Autogenerated by Thr ft Comp ler (0.17.0)
// DO NOT ED T UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DO NG

#![allow(unused_ mports)]
#![allow(unused_extern_crates)]
#![allow(cl ppy::too_many_argu nts, cl ppy::type_complex y, cl ppy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_sk p)]

use std::cell::RefCell;
use std::collect ons::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{D splay, Formatter};
use std::rc::Rc;

use thr ft::OrderedFloat;
use thr ft::{Appl cat onError, Appl cat onErrorK nd, ProtocolError, ProtocolErrorK nd, TThr ftCl ent};
use thr ft::protocol::{TF eld dent f er, TL st dent f er, TMap dent f er, T ssage dent f er, T ssageType, T nputProtocol, TOutputProtocol, TSer al zable, TSet dent f er, TStruct dent f er, TType};
use thr ft::protocol::f eld_ d;
use thr ft::protocol::ver fy_expected_ ssage_type;
use thr ft::protocol::ver fy_expected_sequence_number;
use thr ft::protocol::ver fy_expected_serv ce_call;
use thr ft::protocol::ver fy_requ red_f eld_ex sts;
use thr ft::server::TProcessor;

#[der ve(Copy, Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct DataType(pub  32);

 mpl DataType {
  pub const FLOAT: DataType = DataType(0);
  pub const DOUBLE: DataType = DataType(1);
  pub const  NT32: DataType = DataType(2);
  pub const  NT64: DataType = DataType(3);
  pub const U NT8: DataType = DataType(4);
  pub const STR NG: DataType = DataType(5);
  pub const BYTE: DataType = DataType(6);
  pub const BOOL: DataType = DataType(7);
  pub const RESERVED_1: DataType = DataType(8);
  pub const RESERVED_2: DataType = DataType(9);
  pub const RESERVED_3: DataType = DataType(10);
  pub const ENUM_VALUES: &'stat c [Self] = &[
    Self::FLOAT,
    Self::DOUBLE,
    Self:: NT32,
    Self:: NT64,
    Self::U NT8,
    Self::STR NG,
    Self::BYTE,
    Self::BOOL,
    Self::RESERVED_1,
    Self::RESERVED_2,
    Self::RESERVED_3,
  ];
}

 mpl TSer al zable for DataType {
  #[allow(cl ppy::tr v ally_copy_pass_by_ref)]
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    o_prot.wr e_ 32(self.0)
  }
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<DataType> {
    let enum_value =  _prot.read_ 32()?;
    Ok(DataType::from(enum_value))
  }
}

 mpl From< 32> for DataType {
  fn from( :  32) -> Self {
    match   {
      0 => DataType::FLOAT,
      1 => DataType::DOUBLE,
      2 => DataType:: NT32,
      3 => DataType:: NT64,
      4 => DataType::U NT8,
      5 => DataType::STR NG,
      6 => DataType::BYTE,
      7 => DataType::BOOL,
      8 => DataType::RESERVED_1,
      9 => DataType::RESERVED_2,
      10 => DataType::RESERVED_3,
      _ => DataType( )
    }
  }
}

 mpl From<& 32> for DataType {
  fn from( : & 32) -> Self {
    DataType::from(* )
  }
}

 mpl From<DataType> for  32 {
  fn from(e: DataType) ->  32 {
    e.0
  }
}

 mpl From<&DataType> for  32 {
  fn from(e: &DataType) ->  32 {
    e.0
  }
}

//
// Str ngTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Str ngTensor {
  pub str ngs: Vec<Str ng>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl Str ngTensor {
  pub fn new<F2>(str ngs: Vec<Str ng>, shape: F2) -> Str ngTensor w re F2:  nto<Opt on<Vec< 64>>> {
    Str ngTensor {
      str ngs,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for Str ngTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Str ngTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<Str ng>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<Str ng> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_0 =  _prot.read_str ng()?;
            val.push(l st_elem_0);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_1 =  _prot.read_ 64()?;
            val.push(l st_elem_1);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("Str ngTensor.str ngs", &f_1)?;
    let ret = Str ngTensor {
      str ngs: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Str ngTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("str ngs", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Str ng, self.str ngs.len() as  32))?;
    for e  n &self.str ngs {
      o_prot.wr e_str ng(e)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
//  nt32Tensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct  nt32Tensor {
  pub  nts: Vec< 32>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl  nt32Tensor {
  pub fn new<F2>( nts: Vec< 32>, shape: F2) ->  nt32Tensor w re F2:  nto<Opt on<Vec< 64>>> {
     nt32Tensor {
       nts,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for  nt32Tensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result< nt32Tensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec< 32>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 32> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_2 =  _prot.read_ 32()?;
            val.push(l st_elem_2);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_3 =  _prot.read_ 64()?;
            val.push(l st_elem_3);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts(" nt32Tensor. nts", &f_1)?;
    let ret =  nt32Tensor {
       nts: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new(" nt32Tensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new(" nts", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 32, self. nts.len() as  32))?;
    for e  n &self. nts {
      o_prot.wr e_ 32(*e)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
//  nt64Tensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct  nt64Tensor {
  pub longs: Vec< 64>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl  nt64Tensor {
  pub fn new<F2>(longs: Vec< 64>, shape: F2) ->  nt64Tensor w re F2:  nto<Opt on<Vec< 64>>> {
     nt64Tensor {
      longs,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for  nt64Tensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result< nt64Tensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec< 64>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_4 =  _prot.read_ 64()?;
            val.push(l st_elem_4);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_5 =  _prot.read_ 64()?;
            val.push(l st_elem_5);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts(" nt64Tensor.longs", &f_1)?;
    let ret =  nt64Tensor {
      longs: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new(" nt64Tensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("longs", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, self.longs.len() as  32))?;
    for e  n &self.longs {
      o_prot.wr e_ 64(*e)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// FloatTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct FloatTensor {
  pub floats: Vec<OrderedFloat<f64>>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl FloatTensor {
  pub fn new<F2>(floats: Vec<OrderedFloat<f64>>, shape: F2) -> FloatTensor w re F2:  nto<Opt on<Vec< 64>>> {
    FloatTensor {
      floats,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for FloatTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<FloatTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<OrderedFloat<f64>>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_6 = OrderedFloat::from( _prot.read_double()?);
            val.push(l st_elem_6);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_7 =  _prot.read_ 64()?;
            val.push(l st_elem_7);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("FloatTensor.floats", &f_1)?;
    let ret = FloatTensor {
      floats: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("FloatTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("floats", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Double, self.floats.len() as  32))?;
    for e  n &self.floats {
      o_prot.wr e_double((*e). nto())?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// DoubleTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct DoubleTensor {
  pub doubles: Vec<OrderedFloat<f64>>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl DoubleTensor {
  pub fn new<F2>(doubles: Vec<OrderedFloat<f64>>, shape: F2) -> DoubleTensor w re F2:  nto<Opt on<Vec< 64>>> {
    DoubleTensor {
      doubles,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for DoubleTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<DoubleTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<OrderedFloat<f64>>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_8 = OrderedFloat::from( _prot.read_double()?);
            val.push(l st_elem_8);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_9 =  _prot.read_ 64()?;
            val.push(l st_elem_9);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("DoubleTensor.doubles", &f_1)?;
    let ret = DoubleTensor {
      doubles: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("DoubleTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("doubles", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Double, self.doubles.len() as  32))?;
    for e  n &self.doubles {
      o_prot.wr e_double((*e). nto())?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// BoolTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct BoolTensor {
  pub booleans: Vec<bool>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl BoolTensor {
  pub fn new<F2>(booleans: Vec<bool>, shape: F2) -> BoolTensor w re F2:  nto<Opt on<Vec< 64>>> {
    BoolTensor {
      booleans,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for BoolTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<BoolTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<bool>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<bool> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_10 =  _prot.read_bool()?;
            val.push(l st_elem_10);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_11 =  _prot.read_ 64()?;
            val.push(l st_elem_11);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("BoolTensor.booleans", &f_1)?;
    let ret = BoolTensor {
      booleans: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("BoolTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("booleans", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Bool, self.booleans.len() as  32))?;
    for e  n &self.booleans {
      o_prot.wr e_bool(*e)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// RawTypedTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct RawTypedTensor {
  pub data_type: DataType,
  pub content: Vec<u8>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl RawTypedTensor {
  pub fn new<F3>(data_type: DataType, content: Vec<u8>, shape: F3) -> RawTypedTensor w re F3:  nto<Opt on<Vec< 64>>> {
    RawTypedTensor {
      data_type,
      content,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for RawTypedTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<RawTypedTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<DataType> = None;
    let mut f_2: Opt on<Vec<u8>> = None;
    let mut f_3: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = DataType::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        2 => {
          let val =  _prot.read_bytes()?;
          f_2 = So (val);
        },
        3 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_12 =  _prot.read_ 64()?;
            val.push(l st_elem_12);
          }
           _prot.read_l st_end()?;
          f_3 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("RawTypedTensor.data_type", &f_1)?;
    ver fy_requ red_f eld_ex sts("RawTypedTensor.content", &f_2)?;
    let ret = RawTypedTensor {
      data_type: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      content: f_2.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_3,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("RawTypedTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("dataType", TType:: 32, 1))?;
    self.data_type.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("content", TType::Str ng, 2))?;
    o_prot.wr e_bytes(&self.content)?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 3))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// B naryTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct B naryTensor {
  pub b nar es: Vec<Vec<u8>>,
  pub shape: Opt on<Vec< 64>>,
}

 mpl B naryTensor {
  pub fn new<F2>(b nar es: Vec<Vec<u8>>, shape: F2) -> B naryTensor w re F2:  nto<Opt on<Vec< 64>>> {
    B naryTensor {
      b nar es,
      shape: shape. nto(),
    }
  }
}

 mpl TSer al zable for B naryTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<B naryTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<Vec<u8>>> = None;
    let mut f_2: Opt on<Vec< 64>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<Vec<u8>> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_13 =  _prot.read_bytes()?;
            val.push(l st_elem_13);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_14 =  _prot.read_ 64()?;
            val.push(l st_elem_14);
          }
           _prot.read_l st_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("B naryTensor.b nar es", &f_1)?;
    let ret = B naryTensor {
      b nar es: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      shape: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("B naryTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("b nar es", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Str ng, self.b nar es.len() as  32))?;
    for e  n &self.b nar es {
      o_prot.wr e_bytes(e)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.shape {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("shape", TType::L st, 2))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// GeneralTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub enum GeneralTensor {
  RawTypedTensor(RawTypedTensor),
  Str ngTensor(Str ngTensor),
   nt32Tensor( nt32Tensor),
   nt64Tensor( nt64Tensor),
  FloatTensor(FloatTensor),
  DoubleTensor(DoubleTensor),
  BoolTensor(BoolTensor),
  B naryTensor(B naryTensor),
}

 mpl TSer al zable for GeneralTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<GeneralTensor> {
    let mut ret: Opt on<GeneralTensor> = None;
    let mut rece ved_f eld_count = 0;
     _prot.read_struct_beg n()?;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = RawTypedTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor::RawTypedTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        2 => {
          let val = Str ngTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor::Str ngTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        3 => {
          let val =  nt32Tensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor:: nt32Tensor(val));
          }
          rece ved_f eld_count += 1;
        },
        4 => {
          let val =  nt64Tensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor:: nt64Tensor(val));
          }
          rece ved_f eld_count += 1;
        },
        5 => {
          let val = FloatTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor::FloatTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        6 => {
          let val = DoubleTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor::DoubleTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        7 => {
          let val = BoolTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor::BoolTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        8 => {
          let val = B naryTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (GeneralTensor::B naryTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
          rece ved_f eld_count += 1;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
     f rece ved_f eld_count == 0 {
      Err(
        thr ft::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorK nd:: nval dData,
            "rece ved empty un on from remote GeneralTensor"
          )
        )
      )
    } else  f rece ved_f eld_count > 1 {
      Err(
        thr ft::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorK nd:: nval dData,
            "rece ved mult ple f elds for un on from remote GeneralTensor"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("GeneralTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    match *self {
      GeneralTensor::RawTypedTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("rawTypedTensor", TType::Struct, 1))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor::Str ngTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("str ngTensor", TType::Struct, 2))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor:: nt32Tensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new(" nt32Tensor", TType::Struct, 3))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor:: nt64Tensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new(" nt64Tensor", TType::Struct, 4))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor::FloatTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("floatTensor", TType::Struct, 5))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor::DoubleTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("doubleTensor", TType::Struct, 6))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor::BoolTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("boolTensor", TType::Struct, 7))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
      GeneralTensor::B naryTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("b naryTensor", TType::Struct, 8))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// COOSparseTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct COOSparseTensor {
  pub dense_shape: Vec< 64>,
  pub  nd ces:  nt64Tensor,
  pub values: GeneralTensor,
}

 mpl COOSparseTensor {
  pub fn new(dense_shape: Vec< 64>,  nd ces:  nt64Tensor, values: GeneralTensor) -> COOSparseTensor {
    COOSparseTensor {
      dense_shape,
       nd ces,
      values,
    }
  }
}

 mpl TSer al zable for COOSparseTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<COOSparseTensor> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec< 64>> = None;
    let mut f_2: Opt on< nt64Tensor> = None;
    let mut f_3: Opt on<GeneralTensor> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec< 64> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_15 =  _prot.read_ 64()?;
            val.push(l st_elem_15);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let val =  nt64Tensor::read_from_ n_protocol( _prot)?;
          f_2 = So (val);
        },
        3 => {
          let val = GeneralTensor::read_from_ n_protocol( _prot)?;
          f_3 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("COOSparseTensor.dense_shape", &f_1)?;
    ver fy_requ red_f eld_ex sts("COOSparseTensor. nd ces", &f_2)?;
    ver fy_requ red_f eld_ex sts("COOSparseTensor.values", &f_3)?;
    let ret = COOSparseTensor {
      dense_shape: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
       nd ces: f_2.expect("auto-generated code should have c cked for presence of requ red f elds"),
      values: f_3.expect("auto-generated code should have c cked for presence of requ red f elds"),
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("COOSparseTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("denseShape", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType:: 64, self.dense_shape.len() as  32))?;
    for e  n &self.dense_shape {
      o_prot.wr e_ 64(*e)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new(" nd ces", TType::Struct, 2))?;
    self. nd ces.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("values", TType::Struct, 3))?;
    self.values.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// SparseTensor
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub enum SparseTensor {
  CooSparseTensor(COOSparseTensor),
}

 mpl TSer al zable for SparseTensor {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<SparseTensor> {
    let mut ret: Opt on<SparseTensor> = None;
    let mut rece ved_f eld_count = 0;
     _prot.read_struct_beg n()?;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = COOSparseTensor::read_from_ n_protocol( _prot)?;
           f ret. s_none() {
            ret = So (SparseTensor::CooSparseTensor(val));
          }
          rece ved_f eld_count += 1;
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
          rece ved_f eld_count += 1;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
     f rece ved_f eld_count == 0 {
      Err(
        thr ft::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorK nd:: nval dData,
            "rece ved empty un on from remote SparseTensor"
          )
        )
      )
    } else  f rece ved_f eld_count > 1 {
      Err(
        thr ft::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorK nd:: nval dData,
            "rece ved mult ple f elds for un on from remote SparseTensor"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("SparseTensor");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    match *self {
      SparseTensor::CooSparseTensor(ref f) => {
        o_prot.wr e_f eld_beg n(&TF eld dent f er::new("cooSparseTensor", TType::Struct, 1))?;
        f.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_f eld_end()?;
      },
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

