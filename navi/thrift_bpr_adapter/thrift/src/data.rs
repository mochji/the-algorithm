// Autogenerated by Thr ft Comp ler (0.17.0)
// DO NOT ED T UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DO NG

#![allow(unused_ mports)]
#![allow(unused_extern_crates)]
#![allow(cl ppy::too_many_argu nts, cl ppy::type_complex y, cl ppy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_sk p)]

use std::cell::RefCell;
use std::collect ons::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{D splay, Formatter};
use std::rc::Rc;

use thr ft::OrderedFloat;
use thr ft::{Appl cat onError, Appl cat onErrorK nd, ProtocolError, ProtocolErrorK nd, TThr ftCl ent};
use thr ft::protocol::{TF eld dent f er, TL st dent f er, TMap dent f er, T ssage dent f er, T ssageType, T nputProtocol, TOutputProtocol, TSer al zable, TSet dent f er, TStruct dent f er, TType};
use thr ft::protocol::f eld_ d;
use thr ft::protocol::ver fy_expected_ ssage_type;
use thr ft::protocol::ver fy_expected_sequence_number;
use thr ft::protocol::ver fy_expected_serv ce_call;
use thr ft::protocol::ver fy_requ red_f eld_ex sts;
use thr ft::server::TProcessor;

use crate::tensor;

#[der ve(Copy, Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct FeatureType(pub  32);

 mpl FeatureType {
  pub const B NARY: FeatureType = FeatureType(1);
  pub const CONT NUOUS: FeatureType = FeatureType(2);
  pub const D SCRETE: FeatureType = FeatureType(3);
  pub const STR NG: FeatureType = FeatureType(4);
  pub const SPARSE_B NARY: FeatureType = FeatureType(5);
  pub const SPARSE_CONT NUOUS: FeatureType = FeatureType(6);
  pub const UNKNOWN: FeatureType = FeatureType(7);
  pub const BLOB: FeatureType = FeatureType(8);
  pub const TENSOR: FeatureType = FeatureType(9);
  pub const SPARSE_TENSOR: FeatureType = FeatureType(10);
  pub const FEATURE_TYPE11: FeatureType = FeatureType(11);
  pub const FEATURE_TYPE12: FeatureType = FeatureType(12);
  pub const ENUM_VALUES: &'stat c [Self] = &[
    Self::B NARY,
    Self::CONT NUOUS,
    Self::D SCRETE,
    Self::STR NG,
    Self::SPARSE_B NARY,
    Self::SPARSE_CONT NUOUS,
    Self::UNKNOWN,
    Self::BLOB,
    Self::TENSOR,
    Self::SPARSE_TENSOR,
    Self::FEATURE_TYPE11,
    Self::FEATURE_TYPE12,
  ];
}

 mpl TSer al zable for FeatureType {
  #[allow(cl ppy::tr v ally_copy_pass_by_ref)]
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    o_prot.wr e_ 32(self.0)
  }
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<FeatureType> {
    let enum_value =  _prot.read_ 32()?;
    Ok(FeatureType::from(enum_value))
  }
}

 mpl From< 32> for FeatureType {
  fn from( :  32) -> Self {
    match   {
      1 => FeatureType::B NARY,
      2 => FeatureType::CONT NUOUS,
      3 => FeatureType::D SCRETE,
      4 => FeatureType::STR NG,
      5 => FeatureType::SPARSE_B NARY,
      6 => FeatureType::SPARSE_CONT NUOUS,
      7 => FeatureType::UNKNOWN,
      8 => FeatureType::BLOB,
      9 => FeatureType::TENSOR,
      10 => FeatureType::SPARSE_TENSOR,
      11 => FeatureType::FEATURE_TYPE11,
      12 => FeatureType::FEATURE_TYPE12,
      _ => FeatureType( )
    }
  }
}

 mpl From<& 32> for FeatureType {
  fn from( : & 32) -> Self {
    FeatureType::from(* )
  }
}

 mpl From<FeatureType> for  32 {
  fn from(e: FeatureType) ->  32 {
    e.0
  }
}

 mpl From<&FeatureType> for  32 {
  fn from(e: &FeatureType) ->  32 {
    e.0
  }
}

//
// DataRecord
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct DataRecord {
  pub b nary_features: Opt on<BTreeSet< 64>>,
  pub cont nuous_features: Opt on<BTreeMap< 64, OrderedFloat<f64>>>,
  pub d screte_features: Opt on<BTreeMap< 64,  64>>,
  pub str ng_features: Opt on<BTreeMap< 64, Str ng>>,
  pub sparse_b nary_features: Opt on<BTreeMap< 64, BTreeSet<Str ng>>>,
  pub sparse_cont nuous_features: Opt on<BTreeMap< 64, BTreeMap<Str ng, OrderedFloat<f64>>>>,
  pub blob_features: Opt on<BTreeMap< 64, Vec<u8>>>,
  pub tensors: Opt on<BTreeMap< 64, tensor::GeneralTensor>>,
  pub sparse_tensors: Opt on<BTreeMap< 64, tensor::SparseTensor>>,
}

 mpl DataRecord {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(b nary_features: F1, cont nuous_features: F2, d screte_features: F3, str ng_features: F4, sparse_b nary_features: F5, sparse_cont nuous_features: F6, blob_features: F7, tensors: F8, sparse_tensors: F9) -> DataRecord w re F1:  nto<Opt on<BTreeSet< 64>>>, F2:  nto<Opt on<BTreeMap< 64, OrderedFloat<f64>>>>, F3:  nto<Opt on<BTreeMap< 64,  64>>>, F4:  nto<Opt on<BTreeMap< 64, Str ng>>>, F5:  nto<Opt on<BTreeMap< 64, BTreeSet<Str ng>>>>, F6:  nto<Opt on<BTreeMap< 64, BTreeMap<Str ng, OrderedFloat<f64>>>>>, F7:  nto<Opt on<BTreeMap< 64, Vec<u8>>>>, F8:  nto<Opt on<BTreeMap< 64, tensor::GeneralTensor>>>, F9:  nto<Opt on<BTreeMap< 64, tensor::SparseTensor>>> {
    DataRecord {
      b nary_features: b nary_features. nto(),
      cont nuous_features: cont nuous_features. nto(),
      d screte_features: d screte_features. nto(),
      str ng_features: str ng_features. nto(),
      sparse_b nary_features: sparse_b nary_features. nto(),
      sparse_cont nuous_features: sparse_cont nuous_features. nto(),
      blob_features: blob_features. nto(),
      tensors: tensors. nto(),
      sparse_tensors: sparse_tensors. nto(),
    }
  }
}

 mpl TSer al zable for DataRecord {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<DataRecord> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<BTreeSet< 64>> = None;
    let mut f_2: Opt on<BTreeMap< 64, OrderedFloat<f64>>> = None;
    let mut f_3: Opt on<BTreeMap< 64,  64>> = None;
    let mut f_4: Opt on<BTreeMap< 64, Str ng>> = None;
    let mut f_5: Opt on<BTreeMap< 64, BTreeSet<Str ng>>> = None;
    let mut f_6: Opt on<BTreeMap< 64, BTreeMap<Str ng, OrderedFloat<f64>>>> = None;
    let mut f_7: Opt on<BTreeMap< 64, Vec<u8>>> = None;
    let mut f_8: Opt on<BTreeMap< 64, tensor::GeneralTensor>> = None;
    let mut f_9: Opt on<BTreeMap< 64, tensor::SparseTensor>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let set_ dent =  _prot.read_set_beg n()?;
          let mut val: BTreeSet< 64> = BTreeSet::new();
          for _  n 0..set_ dent.s ze {
            let set_elem_0 =  _prot.read_ 64()?;
            val. nsert(set_elem_0);
          }
           _prot.read_set_end()?;
          f_1 = So (val);
        },
        2 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, OrderedFloat<f64>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_1 =  _prot.read_ 64()?;
            let map_val_2 = OrderedFloat::from( _prot.read_double()?);
            val. nsert(map_key_1, map_val_2);
          }
           _prot.read_map_end()?;
          f_2 = So (val);
        },
        3 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64,  64> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_3 =  _prot.read_ 64()?;
            let map_val_4 =  _prot.read_ 64()?;
            val. nsert(map_key_3, map_val_4);
          }
           _prot.read_map_end()?;
          f_3 = So (val);
        },
        4 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, Str ng> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_5 =  _prot.read_ 64()?;
            let map_val_6 =  _prot.read_str ng()?;
            val. nsert(map_key_5, map_val_6);
          }
           _prot.read_map_end()?;
          f_4 = So (val);
        },
        5 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeSet<Str ng>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_7 =  _prot.read_ 64()?;
            let set_ dent =  _prot.read_set_beg n()?;
            let mut map_val_8: BTreeSet<Str ng> = BTreeSet::new();
            for _  n 0..set_ dent.s ze {
              let set_elem_9 =  _prot.read_str ng()?;
              map_val_8. nsert(set_elem_9);
            }
             _prot.read_set_end()?;
            val. nsert(map_key_7, map_val_8);
          }
           _prot.read_map_end()?;
          f_5 = So (val);
        },
        6 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeMap<Str ng, OrderedFloat<f64>>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_10 =  _prot.read_ 64()?;
            let map_ dent =  _prot.read_map_beg n()?;
            let mut map_val_11: BTreeMap<Str ng, OrderedFloat<f64>> = BTreeMap::new();
            for _  n 0..map_ dent.s ze {
              let map_key_12 =  _prot.read_str ng()?;
              let map_val_13 = OrderedFloat::from( _prot.read_double()?);
              map_val_11. nsert(map_key_12, map_val_13);
            }
             _prot.read_map_end()?;
            val. nsert(map_key_10, map_val_11);
          }
           _prot.read_map_end()?;
          f_6 = So (val);
        },
        7 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, Vec<u8>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_14 =  _prot.read_ 64()?;
            let map_val_15 =  _prot.read_bytes()?;
            val. nsert(map_key_14, map_val_15);
          }
           _prot.read_map_end()?;
          f_7 = So (val);
        },
        8 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, tensor::GeneralTensor> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_16 =  _prot.read_ 64()?;
            let map_val_17 = tensor::GeneralTensor::read_from_ n_protocol( _prot)?;
            val. nsert(map_key_16, map_val_17);
          }
           _prot.read_map_end()?;
          f_8 = So (val);
        },
        9 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, tensor::SparseTensor> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_18 =  _prot.read_ 64()?;
            let map_val_19 = tensor::SparseTensor::read_from_ n_protocol( _prot)?;
            val. nsert(map_key_18, map_val_19);
          }
           _prot.read_map_end()?;
          f_9 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = DataRecord {
      b nary_features: f_1,
      cont nuous_features: f_2,
      d screte_features: f_3,
      str ng_features: f_4,
      sparse_b nary_features: f_5,
      sparse_cont nuous_features: f_6,
      blob_features: f_7,
      tensors: f_8,
      sparse_tensors: f_9,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("DataRecord");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.b nary_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("b naryFeatures", TType::Set, 1))?;
      o_prot.wr e_set_beg n(&TSet dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_set_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.cont nuous_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("cont nuousFeatures", TType::Map, 2))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Double, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_double((*v). nto())?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.d screte_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("d screteFeatures", TType::Map, 3))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType:: 64, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_ 64(*v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.str ng_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("str ngFeatures", TType::Map, 4))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Str ng, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_str ng(v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_b nary_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseB naryFeatures", TType::Map, 5))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Set, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_set_beg n(&TSet dent f er::new(TType::Str ng, v.len() as  32))?;
        for e  n v {
          o_prot.wr e_str ng(e)?;
        }
        o_prot.wr e_set_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_cont nuous_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseCont nuousFeatures", TType::Map, 6))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Map, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_map_beg n(&TMap dent f er::new(TType::Str ng, TType::Double, v.len() as  32))?;
        for (k, v)  n v {
          o_prot.wr e_str ng(k)?;
          o_prot.wr e_double((*v). nto())?;
        }
        o_prot.wr e_map_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.blob_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("blobFeatures", TType::Map, 7))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Str ng, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_bytes(v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.tensors {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("tensors", TType::Map, 8))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Struct, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        v.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_tensors {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseTensors", TType::Map, 9))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Struct, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        v.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for DataRecord {
  fn default() -> Self {
    DataRecord{
      b nary_features: So (BTreeSet::new()),
      cont nuous_features: So (BTreeMap::new()),
      d screte_features: So (BTreeMap::new()),
      str ng_features: So (BTreeMap::new()),
      sparse_b nary_features: So (BTreeMap::new()),
      sparse_cont nuous_features: So (BTreeMap::new()),
      blob_features: So (BTreeMap::new()),
      tensors: So (BTreeMap::new()),
      sparse_tensors: So (BTreeMap::new()),
    }
  }
}

//
// CompactDataRecord
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct CompactDataRecord {
  pub b nary_features: Opt on<BTreeSet< 64>>,
  pub cont nuous_features: Opt on<BTreeMap< 64,  32>>,
  pub d screte_features: Opt on<BTreeMap< 64,  64>>,
  pub str ng_features: Opt on<BTreeMap< 64, Str ng>>,
  pub sparse_b nary_features: Opt on<BTreeMap< 64, BTreeSet<Str ng>>>,
  pub sparse_b nary_features_w h16b_sparse_key: Opt on<BTreeMap< 64, BTreeSet< 16>>>,
  pub sparse_b nary_features_w h32b_sparse_key: Opt on<BTreeMap< 64, BTreeSet< 32>>>,
  pub sparse_b nary_features_w h64b_sparse_key: Opt on<BTreeMap< 64, BTreeSet< 64>>>,
  pub sparse_cont nuous_features: Opt on<BTreeMap< 64, BTreeMap<Str ng,  32>>>,
  pub sparse_cont nuous_features_w h16b_sparse_key: Opt on<BTreeMap< 64, BTreeMap< 16,  32>>>,
  pub sparse_cont nuous_features_w h32b_sparse_key: Opt on<BTreeMap< 64, BTreeMap< 32,  32>>>,
  pub sparse_cont nuous_features_w h64b_sparse_key: Opt on<BTreeMap< 64, BTreeMap< 64,  32>>>,
  pub blob_features: Opt on<BTreeMap< 64, Vec<u8>>>,
  pub tensors: Opt on<BTreeMap< 64, tensor::GeneralTensor>>,
  pub sparse_tensors: Opt on<BTreeMap< 64, tensor::SparseTensor>>,
}

 mpl CompactDataRecord {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15>(b nary_features: F1, cont nuous_features: F2, d screte_features: F3, str ng_features: F4, sparse_b nary_features: F5, sparse_b nary_features_w h16b_sparse_key: F6, sparse_b nary_features_w h32b_sparse_key: F7, sparse_b nary_features_w h64b_sparse_key: F8, sparse_cont nuous_features: F9, sparse_cont nuous_features_w h16b_sparse_key: F10, sparse_cont nuous_features_w h32b_sparse_key: F11, sparse_cont nuous_features_w h64b_sparse_key: F12, blob_features: F13, tensors: F14, sparse_tensors: F15) -> CompactDataRecord w re F1:  nto<Opt on<BTreeSet< 64>>>, F2:  nto<Opt on<BTreeMap< 64,  32>>>, F3:  nto<Opt on<BTreeMap< 64,  64>>>, F4:  nto<Opt on<BTreeMap< 64, Str ng>>>, F5:  nto<Opt on<BTreeMap< 64, BTreeSet<Str ng>>>>, F6:  nto<Opt on<BTreeMap< 64, BTreeSet< 16>>>>, F7:  nto<Opt on<BTreeMap< 64, BTreeSet< 32>>>>, F8:  nto<Opt on<BTreeMap< 64, BTreeSet< 64>>>>, F9:  nto<Opt on<BTreeMap< 64, BTreeMap<Str ng,  32>>>>, F10:  nto<Opt on<BTreeMap< 64, BTreeMap< 16,  32>>>>, F11:  nto<Opt on<BTreeMap< 64, BTreeMap< 32,  32>>>>, F12:  nto<Opt on<BTreeMap< 64, BTreeMap< 64,  32>>>>, F13:  nto<Opt on<BTreeMap< 64, Vec<u8>>>>, F14:  nto<Opt on<BTreeMap< 64, tensor::GeneralTensor>>>, F15:  nto<Opt on<BTreeMap< 64, tensor::SparseTensor>>> {
    CompactDataRecord {
      b nary_features: b nary_features. nto(),
      cont nuous_features: cont nuous_features. nto(),
      d screte_features: d screte_features. nto(),
      str ng_features: str ng_features. nto(),
      sparse_b nary_features: sparse_b nary_features. nto(),
      sparse_b nary_features_w h16b_sparse_key: sparse_b nary_features_w h16b_sparse_key. nto(),
      sparse_b nary_features_w h32b_sparse_key: sparse_b nary_features_w h32b_sparse_key. nto(),
      sparse_b nary_features_w h64b_sparse_key: sparse_b nary_features_w h64b_sparse_key. nto(),
      sparse_cont nuous_features: sparse_cont nuous_features. nto(),
      sparse_cont nuous_features_w h16b_sparse_key: sparse_cont nuous_features_w h16b_sparse_key. nto(),
      sparse_cont nuous_features_w h32b_sparse_key: sparse_cont nuous_features_w h32b_sparse_key. nto(),
      sparse_cont nuous_features_w h64b_sparse_key: sparse_cont nuous_features_w h64b_sparse_key. nto(),
      blob_features: blob_features. nto(),
      tensors: tensors. nto(),
      sparse_tensors: sparse_tensors. nto(),
    }
  }
}

 mpl TSer al zable for CompactDataRecord {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<CompactDataRecord> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<BTreeSet< 64>> = None;
    let mut f_2: Opt on<BTreeMap< 64,  32>> = None;
    let mut f_3: Opt on<BTreeMap< 64,  64>> = None;
    let mut f_4: Opt on<BTreeMap< 64, Str ng>> = None;
    let mut f_5: Opt on<BTreeMap< 64, BTreeSet<Str ng>>> = None;
    let mut f_6: Opt on<BTreeMap< 64, BTreeSet< 16>>> = None;
    let mut f_7: Opt on<BTreeMap< 64, BTreeSet< 32>>> = None;
    let mut f_8: Opt on<BTreeMap< 64, BTreeSet< 64>>> = None;
    let mut f_9: Opt on<BTreeMap< 64, BTreeMap<Str ng,  32>>> = None;
    let mut f_10: Opt on<BTreeMap< 64, BTreeMap< 16,  32>>> = None;
    let mut f_11: Opt on<BTreeMap< 64, BTreeMap< 32,  32>>> = None;
    let mut f_12: Opt on<BTreeMap< 64, BTreeMap< 64,  32>>> = None;
    let mut f_13: Opt on<BTreeMap< 64, Vec<u8>>> = None;
    let mut f_14: Opt on<BTreeMap< 64, tensor::GeneralTensor>> = None;
    let mut f_15: Opt on<BTreeMap< 64, tensor::SparseTensor>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let set_ dent =  _prot.read_set_beg n()?;
          let mut val: BTreeSet< 64> = BTreeSet::new();
          for _  n 0..set_ dent.s ze {
            let set_elem_20 =  _prot.read_ 64()?;
            val. nsert(set_elem_20);
          }
           _prot.read_set_end()?;
          f_1 = So (val);
        },
        2 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64,  32> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_21 =  _prot.read_ 64()?;
            let map_val_22 =  _prot.read_ 32()?;
            val. nsert(map_key_21, map_val_22);
          }
           _prot.read_map_end()?;
          f_2 = So (val);
        },
        3 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64,  64> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_23 =  _prot.read_ 64()?;
            let map_val_24 =  _prot.read_ 64()?;
            val. nsert(map_key_23, map_val_24);
          }
           _prot.read_map_end()?;
          f_3 = So (val);
        },
        4 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, Str ng> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_25 =  _prot.read_ 64()?;
            let map_val_26 =  _prot.read_str ng()?;
            val. nsert(map_key_25, map_val_26);
          }
           _prot.read_map_end()?;
          f_4 = So (val);
        },
        5 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeSet<Str ng>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_27 =  _prot.read_ 64()?;
            let set_ dent =  _prot.read_set_beg n()?;
            let mut map_val_28: BTreeSet<Str ng> = BTreeSet::new();
            for _  n 0..set_ dent.s ze {
              let set_elem_29 =  _prot.read_str ng()?;
              map_val_28. nsert(set_elem_29);
            }
             _prot.read_set_end()?;
            val. nsert(map_key_27, map_val_28);
          }
           _prot.read_map_end()?;
          f_5 = So (val);
        },
        6 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeSet< 16>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_30 =  _prot.read_ 64()?;
            let set_ dent =  _prot.read_set_beg n()?;
            let mut map_val_31: BTreeSet< 16> = BTreeSet::new();
            for _  n 0..set_ dent.s ze {
              let set_elem_32 =  _prot.read_ 16()?;
              map_val_31. nsert(set_elem_32);
            }
             _prot.read_set_end()?;
            val. nsert(map_key_30, map_val_31);
          }
           _prot.read_map_end()?;
          f_6 = So (val);
        },
        7 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeSet< 32>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_33 =  _prot.read_ 64()?;
            let set_ dent =  _prot.read_set_beg n()?;
            let mut map_val_34: BTreeSet< 32> = BTreeSet::new();
            for _  n 0..set_ dent.s ze {
              let set_elem_35 =  _prot.read_ 32()?;
              map_val_34. nsert(set_elem_35);
            }
             _prot.read_set_end()?;
            val. nsert(map_key_33, map_val_34);
          }
           _prot.read_map_end()?;
          f_7 = So (val);
        },
        8 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeSet< 64>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_36 =  _prot.read_ 64()?;
            let set_ dent =  _prot.read_set_beg n()?;
            let mut map_val_37: BTreeSet< 64> = BTreeSet::new();
            for _  n 0..set_ dent.s ze {
              let set_elem_38 =  _prot.read_ 64()?;
              map_val_37. nsert(set_elem_38);
            }
             _prot.read_set_end()?;
            val. nsert(map_key_36, map_val_37);
          }
           _prot.read_map_end()?;
          f_8 = So (val);
        },
        9 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeMap<Str ng,  32>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_39 =  _prot.read_ 64()?;
            let map_ dent =  _prot.read_map_beg n()?;
            let mut map_val_40: BTreeMap<Str ng,  32> = BTreeMap::new();
            for _  n 0..map_ dent.s ze {
              let map_key_41 =  _prot.read_str ng()?;
              let map_val_42 =  _prot.read_ 32()?;
              map_val_40. nsert(map_key_41, map_val_42);
            }
             _prot.read_map_end()?;
            val. nsert(map_key_39, map_val_40);
          }
           _prot.read_map_end()?;
          f_9 = So (val);
        },
        10 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeMap< 16,  32>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_43 =  _prot.read_ 64()?;
            let map_ dent =  _prot.read_map_beg n()?;
            let mut map_val_44: BTreeMap< 16,  32> = BTreeMap::new();
            for _  n 0..map_ dent.s ze {
              let map_key_45 =  _prot.read_ 16()?;
              let map_val_46 =  _prot.read_ 32()?;
              map_val_44. nsert(map_key_45, map_val_46);
            }
             _prot.read_map_end()?;
            val. nsert(map_key_43, map_val_44);
          }
           _prot.read_map_end()?;
          f_10 = So (val);
        },
        11 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeMap< 32,  32>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_47 =  _prot.read_ 64()?;
            let map_ dent =  _prot.read_map_beg n()?;
            let mut map_val_48: BTreeMap< 32,  32> = BTreeMap::new();
            for _  n 0..map_ dent.s ze {
              let map_key_49 =  _prot.read_ 32()?;
              let map_val_50 =  _prot.read_ 32()?;
              map_val_48. nsert(map_key_49, map_val_50);
            }
             _prot.read_map_end()?;
            val. nsert(map_key_47, map_val_48);
          }
           _prot.read_map_end()?;
          f_11 = So (val);
        },
        12 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, BTreeMap< 64,  32>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_51 =  _prot.read_ 64()?;
            let map_ dent =  _prot.read_map_beg n()?;
            let mut map_val_52: BTreeMap< 64,  32> = BTreeMap::new();
            for _  n 0..map_ dent.s ze {
              let map_key_53 =  _prot.read_ 64()?;
              let map_val_54 =  _prot.read_ 32()?;
              map_val_52. nsert(map_key_53, map_val_54);
            }
             _prot.read_map_end()?;
            val. nsert(map_key_51, map_val_52);
          }
           _prot.read_map_end()?;
          f_12 = So (val);
        },
        13 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, Vec<u8>> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_55 =  _prot.read_ 64()?;
            let map_val_56 =  _prot.read_bytes()?;
            val. nsert(map_key_55, map_val_56);
          }
           _prot.read_map_end()?;
          f_13 = So (val);
        },
        14 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, tensor::GeneralTensor> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_57 =  _prot.read_ 64()?;
            let map_val_58 = tensor::GeneralTensor::read_from_ n_protocol( _prot)?;
            val. nsert(map_key_57, map_val_58);
          }
           _prot.read_map_end()?;
          f_14 = So (val);
        },
        15 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, tensor::SparseTensor> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_59 =  _prot.read_ 64()?;
            let map_val_60 = tensor::SparseTensor::read_from_ n_protocol( _prot)?;
            val. nsert(map_key_59, map_val_60);
          }
           _prot.read_map_end()?;
          f_15 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = CompactDataRecord {
      b nary_features: f_1,
      cont nuous_features: f_2,
      d screte_features: f_3,
      str ng_features: f_4,
      sparse_b nary_features: f_5,
      sparse_b nary_features_w h16b_sparse_key: f_6,
      sparse_b nary_features_w h32b_sparse_key: f_7,
      sparse_b nary_features_w h64b_sparse_key: f_8,
      sparse_cont nuous_features: f_9,
      sparse_cont nuous_features_w h16b_sparse_key: f_10,
      sparse_cont nuous_features_w h32b_sparse_key: f_11,
      sparse_cont nuous_features_w h64b_sparse_key: f_12,
      blob_features: f_13,
      tensors: f_14,
      sparse_tensors: f_15,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("CompactDataRecord");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.b nary_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("b naryFeatures", TType::Set, 1))?;
      o_prot.wr e_set_beg n(&TSet dent f er::new(TType:: 64, fld_var.len() as  32))?;
      for e  n fld_var {
        o_prot.wr e_ 64(*e)?;
      }
      o_prot.wr e_set_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.cont nuous_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("cont nuousFeatures", TType::Map, 2))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType:: 32, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_ 32(*v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.d screte_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("d screteFeatures", TType::Map, 3))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType:: 64, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_ 64(*v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.str ng_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("str ngFeatures", TType::Map, 4))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Str ng, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_str ng(v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_b nary_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseB naryFeatures", TType::Map, 5))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Set, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_set_beg n(&TSet dent f er::new(TType::Str ng, v.len() as  32))?;
        for e  n v {
          o_prot.wr e_str ng(e)?;
        }
        o_prot.wr e_set_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_b nary_features_w h16b_sparse_key {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseB naryFeaturesW h16bSparseKey", TType::Map, 6))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Set, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_set_beg n(&TSet dent f er::new(TType:: 16, v.len() as  32))?;
        for e  n v {
          o_prot.wr e_ 16(*e)?;
        }
        o_prot.wr e_set_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_b nary_features_w h32b_sparse_key {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseB naryFeaturesW h32bSparseKey", TType::Map, 7))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Set, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_set_beg n(&TSet dent f er::new(TType:: 32, v.len() as  32))?;
        for e  n v {
          o_prot.wr e_ 32(*e)?;
        }
        o_prot.wr e_set_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_b nary_features_w h64b_sparse_key {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseB naryFeaturesW h64bSparseKey", TType::Map, 8))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Set, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_set_beg n(&TSet dent f er::new(TType:: 64, v.len() as  32))?;
        for e  n v {
          o_prot.wr e_ 64(*e)?;
        }
        o_prot.wr e_set_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_cont nuous_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseCont nuousFeatures", TType::Map, 9))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Map, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_map_beg n(&TMap dent f er::new(TType::Str ng, TType:: 32, v.len() as  32))?;
        for (k, v)  n v {
          o_prot.wr e_str ng(k)?;
          o_prot.wr e_ 32(*v)?;
        }
        o_prot.wr e_map_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_cont nuous_features_w h16b_sparse_key {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseCont nuousFeaturesW h16bSparseKey", TType::Map, 10))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Map, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 16, TType:: 32, v.len() as  32))?;
        for (k, v)  n v {
          o_prot.wr e_ 16(*k)?;
          o_prot.wr e_ 32(*v)?;
        }
        o_prot.wr e_map_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_cont nuous_features_w h32b_sparse_key {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseCont nuousFeaturesW h32bSparseKey", TType::Map, 11))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Map, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 32, TType:: 32, v.len() as  32))?;
        for (k, v)  n v {
          o_prot.wr e_ 32(*k)?;
          o_prot.wr e_ 32(*v)?;
        }
        o_prot.wr e_map_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_cont nuous_features_w h64b_sparse_key {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseCont nuousFeaturesW h64bSparseKey", TType::Map, 12))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Map, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType:: 32, v.len() as  32))?;
        for (k, v)  n v {
          o_prot.wr e_ 64(*k)?;
          o_prot.wr e_ 32(*v)?;
        }
        o_prot.wr e_map_end()?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.blob_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("blobFeatures", TType::Map, 13))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Str ng, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        o_prot.wr e_bytes(v)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.tensors {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("tensors", TType::Map, 14))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Struct, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        v.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_tensors {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseTensors", TType::Map, 15))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Struct, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        v.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for CompactDataRecord {
  fn default() -> Self {
    CompactDataRecord{
      b nary_features: So (BTreeSet::new()),
      cont nuous_features: So (BTreeMap::new()),
      d screte_features: So (BTreeMap::new()),
      str ng_features: So (BTreeMap::new()),
      sparse_b nary_features: So (BTreeMap::new()),
      sparse_b nary_features_w h16b_sparse_key: So (BTreeMap::new()),
      sparse_b nary_features_w h32b_sparse_key: So (BTreeMap::new()),
      sparse_b nary_features_w h64b_sparse_key: So (BTreeMap::new()),
      sparse_cont nuous_features: So (BTreeMap::new()),
      sparse_cont nuous_features_w h16b_sparse_key: So (BTreeMap::new()),
      sparse_cont nuous_features_w h32b_sparse_key: So (BTreeMap::new()),
      sparse_cont nuous_features_w h64b_sparse_key: So (BTreeMap::new()),
      blob_features: So (BTreeMap::new()),
      tensors: So (BTreeMap::new()),
      sparse_tensors: So (BTreeMap::new()),
    }
  }
}

//
// TensorRecord
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct TensorRecord {
  pub tensors: Opt on<BTreeMap< 64, tensor::GeneralTensor>>,
  pub sparse_tensors: Opt on<BTreeMap< 64, tensor::SparseTensor>>,
}

 mpl TensorRecord {
  pub fn new<F1, F2>(tensors: F1, sparse_tensors: F2) -> TensorRecord w re F1:  nto<Opt on<BTreeMap< 64, tensor::GeneralTensor>>>, F2:  nto<Opt on<BTreeMap< 64, tensor::SparseTensor>>> {
    TensorRecord {
      tensors: tensors. nto(),
      sparse_tensors: sparse_tensors. nto(),
    }
  }
}

 mpl TSer al zable for TensorRecord {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<TensorRecord> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<BTreeMap< 64, tensor::GeneralTensor>> = None;
    let mut f_2: Opt on<BTreeMap< 64, tensor::SparseTensor>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, tensor::GeneralTensor> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_61 =  _prot.read_ 64()?;
            let map_val_62 = tensor::GeneralTensor::read_from_ n_protocol( _prot)?;
            val. nsert(map_key_61, map_val_62);
          }
           _prot.read_map_end()?;
          f_1 = So (val);
        },
        2 => {
          let map_ dent =  _prot.read_map_beg n()?;
          let mut val: BTreeMap< 64, tensor::SparseTensor> = BTreeMap::new();
          for _  n 0..map_ dent.s ze {
            let map_key_63 =  _prot.read_ 64()?;
            let map_val_64 = tensor::SparseTensor::read_from_ n_protocol( _prot)?;
            val. nsert(map_key_63, map_val_64);
          }
           _prot.read_map_end()?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = TensorRecord {
      tensors: f_1,
      sparse_tensors: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("TensorRecord");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.tensors {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("tensors", TType::Map, 1))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Struct, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        v.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.sparse_tensors {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("sparseTensors", TType::Map, 2))?;
      o_prot.wr e_map_beg n(&TMap dent f er::new(TType:: 64, TType::Struct, fld_var.len() as  32))?;
      for (k, v)  n fld_var {
        o_prot.wr e_ 64(*k)?;
        v.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_map_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for TensorRecord {
  fn default() -> Self {
    TensorRecord{
      tensors: So (BTreeMap::new()),
      sparse_tensors: So (BTreeMap::new()),
    }
  }
}

//
// Feature ta nfo
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Feature ta nfo {
  pub feature_ d: Opt on< 64>,
  pub full_feature_na : Opt on<Str ng>,
  pub feature_type: Opt on<FeatureType>,
}

 mpl Feature ta nfo {
  pub fn new<F1, F2, F3>(feature_ d: F1, full_feature_na : F2, feature_type: F3) -> Feature ta nfo w re F1:  nto<Opt on< 64>>, F2:  nto<Opt on<Str ng>>, F3:  nto<Opt on<FeatureType>> {
    Feature ta nfo {
      feature_ d: feature_ d. nto(),
      full_feature_na : full_feature_na . nto(),
      feature_type: feature_type. nto(),
    }
  }
}

 mpl TSer al zable for Feature ta nfo {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Feature ta nfo> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on< 64> = None;
    let mut f_2: Opt on<Str ng> = None;
    let mut f_3: Opt on<FeatureType> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val =  _prot.read_ 64()?;
          f_1 = So (val);
        },
        2 => {
          let val =  _prot.read_str ng()?;
          f_2 = So (val);
        },
        3 => {
          let val = FeatureType::read_from_ n_protocol( _prot)?;
          f_3 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = Feature ta nfo {
      feature_ d: f_1,
      full_feature_na : f_2,
      feature_type: f_3,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Feature ta nfo");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (fld_var) = self.feature_ d {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("feature d", TType:: 64, 1))?;
      o_prot.wr e_ 64(fld_var)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.full_feature_na  {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("fullFeatureNa ", TType::Str ng, 2))?;
      o_prot.wr e_str ng(fld_var)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.feature_type {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("featureType", TType:: 32, 3))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for Feature ta nfo {
  fn default() -> Self {
    Feature ta nfo{
      feature_ d: So (0),
      full_feature_na : So ("".to_owned()),
      feature_type: None,
    }
  }
}

//
// Feature ta nfoL st
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Feature ta nfoL st {
  pub contents: Opt on<Vec<Feature ta nfo>>,
}

 mpl Feature ta nfoL st {
  pub fn new<F1>(contents: F1) -> Feature ta nfoL st w re F1:  nto<Opt on<Vec<Feature ta nfo>>> {
    Feature ta nfoL st {
      contents: contents. nto(),
    }
  }
}

 mpl TSer al zable for Feature ta nfoL st {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Feature ta nfoL st> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<Feature ta nfo>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<Feature ta nfo> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_65 = Feature ta nfo::read_from_ n_protocol( _prot)?;
            val.push(l st_elem_65);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = Feature ta nfoL st {
      contents: f_1,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Feature ta nfoL st");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.contents {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("contents", TType::L st, 1))?;
      o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Struct, fld_var.len() as  32))?;
      for e  n fld_var {
        e.wr e_to_out_protocol(o_prot)?;
      }
      o_prot.wr e_l st_end()?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for Feature ta nfoL st {
  fn default() -> Self {
    Feature ta nfoL st{
      contents: So (Vec::new()),
    }
  }
}

