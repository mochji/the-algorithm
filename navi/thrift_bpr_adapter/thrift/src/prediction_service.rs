// Autogenerated by Thr ft Comp ler (0.17.0)
// DO NOT ED T UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DO NG

#![allow(unused_ mports)]
#![allow(unused_extern_crates)]
#![allow(cl ppy::too_many_argu nts, cl ppy::type_complex y, cl ppy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_sk p)]

use std::cell::RefCell;
use std::collect ons::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{D splay, Formatter};
use std::rc::Rc;

use thr ft::OrderedFloat;
use thr ft::{Appl cat onError, Appl cat onErrorK nd, ProtocolError, ProtocolErrorK nd, TThr ftCl ent};
use thr ft::protocol::{TF eld dent f er, TL st dent f er, TMap dent f er, T ssage dent f er, T ssageType, T nputProtocol, TOutputProtocol, TSer al zable, TSet dent f er, TStruct dent f er, TType};
use thr ft::protocol::f eld_ d;
use thr ft::protocol::ver fy_expected_ ssage_type;
use thr ft::protocol::ver fy_expected_sequence_number;
use thr ft::protocol::ver fy_expected_serv ce_call;
use thr ft::protocol::ver fy_requ red_f eld_ex sts;
use thr ft::server::TProcessor;

use crate::data;

//
// Pred ct onServ ceExcept on
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Pred ct onServ ceExcept on {
  pub descr pt on: Opt on<Str ng>,
}

 mpl Pred ct onServ ceExcept on {
  pub fn new<F1>(descr pt on: F1) -> Pred ct onServ ceExcept on w re F1:  nto<Opt on<Str ng>> {
    Pred ct onServ ceExcept on {
      descr pt on: descr pt on. nto(),
    }
  }
}

 mpl TSer al zable for Pred ct onServ ceExcept on {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onServ ceExcept on> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Str ng> = So ("".to_owned());
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val =  _prot.read_str ng()?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = Pred ct onServ ceExcept on {
      descr pt on: f_1,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Pred ct onServ ceExcept on");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.descr pt on {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("descr pt on", TType::Str ng, 1))?;
      o_prot.wr e_str ng(fld_var)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for Pred ct onServ ceExcept on {
  fn default() -> Self {
    Pred ct onServ ceExcept on{
      descr pt on: So ("".to_owned()),
    }
  }
}

 mpl Error for Pred ct onServ ceExcept on {}

 mpl From<Pred ct onServ ceExcept on> for thr ft::Error {
  fn from(e: Pred ct onServ ceExcept on) -> Self {
    thr ft::Error::User(Box::new(e))
  }
}

 mpl D splay for Pred ct onServ ceExcept on {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    wr e!(f, "remote serv ce threw Pred ct onServ ceExcept on")
  }
}

//
// Pred ct onRequest
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Pred ct onRequest {
  pub features: data::DataRecord,
}

 mpl Pred ct onRequest {
  pub fn new(features: data::DataRecord) -> Pred ct onRequest {
    Pred ct onRequest {
      features,
    }
  }
}

 mpl TSer al zable for Pred ct onRequest {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onRequest> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<data::DataRecord> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = data::DataRecord::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("Pred ct onRequest.features", &f_1)?;
    let ret = Pred ct onRequest {
      features: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Pred ct onRequest");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("features", TType::Struct, 1))?;
    self.features.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// Pred ct onResponse
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Pred ct onResponse {
  pub pred ct on: data::DataRecord,
}

 mpl Pred ct onResponse {
  pub fn new(pred ct on: data::DataRecord) -> Pred ct onResponse {
    Pred ct onResponse {
      pred ct on,
    }
  }
}

 mpl TSer al zable for Pred ct onResponse {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onResponse> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<data::DataRecord> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = data::DataRecord::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("Pred ct onResponse.pred ct on", &f_1)?;
    let ret = Pred ct onResponse {
      pred ct on: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Pred ct onResponse");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("pred ct on", TType::Struct, 1))?;
    self.pred ct on.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// BatchPred ct onRequest
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct BatchPred ct onRequest {
  pub  nd v dual_features_l st: Vec<data::DataRecord>,
  pub common_features: Opt on<data::DataRecord>,
}

 mpl BatchPred ct onRequest {
  pub fn new<F2>( nd v dual_features_l st: Vec<data::DataRecord>, common_features: F2) -> BatchPred ct onRequest w re F2:  nto<Opt on<data::DataRecord>> {
    BatchPred ct onRequest {
       nd v dual_features_l st,
      common_features: common_features. nto(),
    }
  }
}

 mpl TSer al zable for BatchPred ct onRequest {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<BatchPred ct onRequest> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<data::DataRecord>> = None;
    let mut f_2: Opt on<data::DataRecord> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<data::DataRecord> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_0 = data::DataRecord::read_from_ n_protocol( _prot)?;
            val.push(l st_elem_0);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        2 => {
          let val = data::DataRecord::read_from_ n_protocol( _prot)?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("BatchPred ct onRequest. nd v dual_features_l st", &f_1)?;
    let ret = BatchPred ct onRequest {
       nd v dual_features_l st: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
      common_features: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("BatchPred ct onRequest");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new(" nd v dualFeaturesL st", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Struct, self. nd v dual_features_l st.len() as  32))?;
    for e  n &self. nd v dual_features_l st {
      e.wr e_to_out_protocol(o_prot)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
     f let So (ref fld_var) = self.common_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("commonFeatures", TType::Struct, 2))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// BatchPred ct onResponse
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct BatchPred ct onResponse {
  pub pred ct ons: Vec<data::DataRecord>,
}

 mpl BatchPred ct onResponse {
  pub fn new(pred ct ons: Vec<data::DataRecord>) -> BatchPred ct onResponse {
    BatchPred ct onResponse {
      pred ct ons,
    }
  }
}

 mpl TSer al zable for BatchPred ct onResponse {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<BatchPred ct onResponse> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Vec<data::DataRecord>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let l st_ dent =  _prot.read_l st_beg n()?;
          let mut val: Vec<data::DataRecord> = Vec::w h_capac y(l st_ dent.s ze as us ze);
          for _  n 0..l st_ dent.s ze {
            let l st_elem_1 = data::DataRecord::read_from_ n_protocol( _prot)?;
            val.push(l st_elem_1);
          }
           _prot.read_l st_end()?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("BatchPred ct onResponse.pred ct ons", &f_1)?;
    let ret = BatchPred ct onResponse {
      pred ct ons: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("BatchPred ct onResponse");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("pred ct ons", TType::L st, 1))?;
    o_prot.wr e_l st_beg n(&TL st dent f er::new(TType::Struct, self.pred ct ons.len() as  32))?;
    for e  n &self.pred ct ons {
      e.wr e_to_out_protocol(o_prot)?;
    }
    o_prot.wr e_l st_end()?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// DataRecordPa r
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct DataRecordPa r {
  pub f rst: Opt on<data::DataRecord>,
  pub second: Opt on<data::DataRecord>,
}

 mpl DataRecordPa r {
  pub fn new<F1, F2>(f rst: F1, second: F2) -> DataRecordPa r w re F1:  nto<Opt on<data::DataRecord>>, F2:  nto<Opt on<data::DataRecord>> {
    DataRecordPa r {
      f rst: f rst. nto(),
      second: second. nto(),
    }
  }
}

 mpl TSer al zable for DataRecordPa r {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<DataRecordPa r> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<data::DataRecord> = None;
    let mut f_2: Opt on<data::DataRecord> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = data::DataRecord::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        2 => {
          let val = data::DataRecord::read_from_ n_protocol( _prot)?;
          f_2 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = DataRecordPa r {
      f rst: f_1,
      second: f_2,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("DataRecordPa r");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.f rst {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("f rst", TType::Struct, 1))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.second {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("second", TType::Struct, 2))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for DataRecordPa r {
  fn default() -> Self {
    DataRecordPa r{
      f rst: None,
      second: None,
    }
  }
}

//
// Pred ct onTra n ngExample
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
pub struct Pred ct onTra n ngExample {
  pub features: Opt on<data::DataRecord>,
  pub features_for_pa rw se_learn ng: Opt on<DataRecordPa r>,
  pub compact_features: Opt on<data::CompactDataRecord>,
  pub compressed_data_record: Opt on<Vec<u8>>,
}

 mpl Pred ct onTra n ngExample {
  pub fn new<F1, F2, F3, F4>(features: F1, features_for_pa rw se_learn ng: F2, compact_features: F3, compressed_data_record: F4) -> Pred ct onTra n ngExample w re F1:  nto<Opt on<data::DataRecord>>, F2:  nto<Opt on<DataRecordPa r>>, F3:  nto<Opt on<data::CompactDataRecord>>, F4:  nto<Opt on<Vec<u8>>> {
    Pred ct onTra n ngExample {
      features: features. nto(),
      features_for_pa rw se_learn ng: features_for_pa rw se_learn ng. nto(),
      compact_features: compact_features. nto(),
      compressed_data_record: compressed_data_record. nto(),
    }
  }
}

 mpl TSer al zable for Pred ct onTra n ngExample {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onTra n ngExample> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<data::DataRecord> = None;
    let mut f_2: Opt on<DataRecordPa r> = None;
    let mut f_3: Opt on<data::CompactDataRecord> = None;
    let mut f_4: Opt on<Vec<u8>> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = data::DataRecord::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        2 => {
          let val = DataRecordPa r::read_from_ n_protocol( _prot)?;
          f_2 = So (val);
        },
        3 => {
          let val = data::CompactDataRecord::read_from_ n_protocol( _prot)?;
          f_3 = So (val);
        },
        4 => {
          let val =  _prot.read_bytes()?;
          f_4 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = Pred ct onTra n ngExample {
      features: f_1,
      features_for_pa rw se_learn ng: f_2,
      compact_features: f_3,
      compressed_data_record: f_4,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Pred ct onTra n ngExample");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("features", TType::Struct, 1))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.features_for_pa rw se_learn ng {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("featuresForPa rw seLearn ng", TType::Struct, 2))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.compact_features {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("compactFeatures", TType::Struct, 3))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.compressed_data_record {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("compressedDataRecord", TType::Str ng, 4))?;
      o_prot.wr e_bytes(fld_var)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

 mpl Default for Pred ct onTra n ngExample {
  fn default() -> Self {
    Pred ct onTra n ngExample{
      features: None,
      features_for_pa rw se_learn ng: None,
      compact_features: None,
      compressed_data_record: So (Vec::new()),
    }
  }
}

//
// Pred ct onServ ce serv ce cl ent
//

pub tra  TPred ct onServ ceSyncCl ent {
  fn get_pred ct on(&mut self, request: Pred ct onRequest) -> thr ft::Result<Pred ct onResponse>;
  fn get_batch_pred ct on(&mut self, batch_request: BatchPred ct onRequest) -> thr ft::Result<BatchPred ct onResponse>;
}

pub tra  TPred ct onServ ceSyncCl entMarker {}

pub struct Pred ct onServ ceSyncCl ent< P, OP> w re  P: T nputProtocol, OP: TOutputProtocol {
  _ _prot:  P,
  _o_prot: OP,
  _sequence_number:  32,
}

 mpl < P, OP> Pred ct onServ ceSyncCl ent< P, OP> w re  P: T nputProtocol, OP: TOutputProtocol {
  pub fn new( nput_protocol:  P, output_protocol: OP) -> Pred ct onServ ceSyncCl ent< P, OP> {
    Pred ct onServ ceSyncCl ent { _ _prot:  nput_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

 mpl < P, OP> TThr ftCl ent for Pred ct onServ ceSyncCl ent< P, OP> w re  P: T nputProtocol, OP: TOutputProtocol {
  fn  _prot_mut(&mut self) -> &mut dyn T nputProtocol { &mut self._ _prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) ->  32 { self._sequence_number }
  fn  ncre nt_sequence_number(&mut self) ->  32 { self._sequence_number += 1; self._sequence_number }
}

 mpl < P, OP> TPred ct onServ ceSyncCl entMarker for Pred ct onServ ceSyncCl ent< P, OP> w re  P: T nputProtocol, OP: TOutputProtocol {}

 mpl <C: TThr ftCl ent + TPred ct onServ ceSyncCl entMarker> TPred ct onServ ceSyncCl ent for C {
  fn get_pred ct on(&mut self, request: Pred ct onRequest) -> thr ft::Result<Pred ct onResponse> {
    (
      {
        self. ncre nt_sequence_number();
        let  ssage_ dent = T ssage dent f er::new("getPred ct on", T ssageType::Call, self.sequence_number());
        let call_args = Pred ct onServ ceGetPred ct onArgs { request };
        self.o_prot_mut().wr e_ ssage_beg n(& ssage_ dent)?;
        call_args.wr e_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().wr e_ ssage_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let  ssage_ dent = self. _prot_mut().read_ ssage_beg n()?;
      ver fy_expected_sequence_number(self.sequence_number(),  ssage_ dent.sequence_number)?;
      ver fy_expected_serv ce_call("getPred ct on", & ssage_ dent.na )?;
       f  ssage_ dent. ssage_type == T ssageType::Except on {
        let remote_error = thr ft::Error::read_appl cat on_error_from_ n_protocol(self. _prot_mut())?;
        self. _prot_mut().read_ ssage_end()?;
        return Err(thr ft::Error::Appl cat on(remote_error))
      }
      ver fy_expected_ ssage_type(T ssageType::Reply,  ssage_ dent. ssage_type)?;
      let result = Pred ct onServ ceGetPred ct onResult::read_from_ n_protocol(self. _prot_mut())?;
      self. _prot_mut().read_ ssage_end()?;
      result.ok_or()
    }
  }
  fn get_batch_pred ct on(&mut self, batch_request: BatchPred ct onRequest) -> thr ft::Result<BatchPred ct onResponse> {
    (
      {
        self. ncre nt_sequence_number();
        let  ssage_ dent = T ssage dent f er::new("getBatchPred ct on", T ssageType::Call, self.sequence_number());
        let call_args = Pred ct onServ ceGetBatchPred ct onArgs { batch_request };
        self.o_prot_mut().wr e_ ssage_beg n(& ssage_ dent)?;
        call_args.wr e_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().wr e_ ssage_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let  ssage_ dent = self. _prot_mut().read_ ssage_beg n()?;
      ver fy_expected_sequence_number(self.sequence_number(),  ssage_ dent.sequence_number)?;
      ver fy_expected_serv ce_call("getBatchPred ct on", & ssage_ dent.na )?;
       f  ssage_ dent. ssage_type == T ssageType::Except on {
        let remote_error = thr ft::Error::read_appl cat on_error_from_ n_protocol(self. _prot_mut())?;
        self. _prot_mut().read_ ssage_end()?;
        return Err(thr ft::Error::Appl cat on(remote_error))
      }
      ver fy_expected_ ssage_type(T ssageType::Reply,  ssage_ dent. ssage_type)?;
      let result = Pred ct onServ ceGetBatchPred ct onResult::read_from_ n_protocol(self. _prot_mut())?;
      self. _prot_mut().read_ ssage_end()?;
      result.ok_or()
    }
  }
}

//
// Pred ct onServ ce serv ce processor
//

pub tra  Pred ct onServ ceSyncHandler {
  fn handle_get_pred ct on(&self, request: Pred ct onRequest) -> thr ft::Result<Pred ct onResponse>;
  fn handle_get_batch_pred ct on(&self, batch_request: BatchPred ct onRequest) -> thr ft::Result<BatchPred ct onResponse>;
}

pub struct Pred ct onServ ceSyncProcessor<H: Pred ct onServ ceSyncHandler> {
  handler: H,
}

 mpl <H: Pred ct onServ ceSyncHandler> Pred ct onServ ceSyncProcessor<H> {
  pub fn new(handler: H) -> Pred ct onServ ceSyncProcessor<H> {
    Pred ct onServ ceSyncProcessor {
      handler,
    }
  }
  fn process_get_pred ct on(&self,  ncom ng_sequence_number:  32,  _prot: &mut dyn T nputProtocol, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    TPred ct onServ ceProcessFunct ons::process_get_pred ct on(&self.handler,  ncom ng_sequence_number,  _prot, o_prot)
  }
  fn process_get_batch_pred ct on(&self,  ncom ng_sequence_number:  32,  _prot: &mut dyn T nputProtocol, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    TPred ct onServ ceProcessFunct ons::process_get_batch_pred ct on(&self.handler,  ncom ng_sequence_number,  _prot, o_prot)
  }
}

pub struct TPred ct onServ ceProcessFunct ons;

 mpl TPred ct onServ ceProcessFunct ons {
  pub fn process_get_pred ct on<H: Pred ct onServ ceSyncHandler>(handler: &H,  ncom ng_sequence_number:  32,  _prot: &mut dyn T nputProtocol, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let args = Pred ct onServ ceGetPred ct onArgs::read_from_ n_protocol( _prot)?;
    match handler.handle_get_pred ct on(args.request) {
      Ok(handler_return) => {
        let  ssage_ dent = T ssage dent f er::new("getPred ct on", T ssageType::Reply,  ncom ng_sequence_number);
        o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
        let ret = Pred ct onServ ceGetPred ct onResult { result_value: So (handler_return), pred ct on_serv ce_except on: None };
        ret.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_ ssage_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thr ft::Error::User(usr_err) => {
             f usr_err.downcast_ref::<Pred ct onServ ceExcept on>(). s_so () {
              let err = usr_err.downcast::<Pred ct onServ ceExcept on>().expect("downcast already c cked");
              let ret_err = Pred ct onServ ceGetPred ct onResult{ result_value: None, pred ct on_serv ce_except on: So (*err) };
              let  ssage_ dent = T ssage dent f er::new("getPred ct on", T ssageType::Reply,  ncom ng_sequence_number);
              o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
              ret_err.wr e_to_out_protocol(o_prot)?;
              o_prot.wr e_ ssage_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                Appl cat onError::new(
                  Appl cat onErrorK nd::Unknown,
                  usr_err.to_str ng()
                )
              };
              let  ssage_ dent = T ssage dent f er::new("getPred ct on", T ssageType::Except on,  ncom ng_sequence_number);
              o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
              thr ft::Error::wr e_appl cat on_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.wr e_ ssage_end()?;
              o_prot.flush()
            }
          },
          thr ft::Error::Appl cat on(app_err) => {
            let  ssage_ dent = T ssage dent f er::new("getPred ct on", T ssageType::Except on,  ncom ng_sequence_number);
            o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
            thr ft::Error::wr e_appl cat on_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.wr e_ ssage_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              Appl cat onError::new(
                Appl cat onErrorK nd::Unknown,
                e.to_str ng()
              )
            };
            let  ssage_ dent = T ssage dent f er::new("getPred ct on", T ssageType::Except on,  ncom ng_sequence_number);
            o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
            thr ft::Error::wr e_appl cat on_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.wr e_ ssage_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_batch_pred ct on<H: Pred ct onServ ceSyncHandler>(handler: &H,  ncom ng_sequence_number:  32,  _prot: &mut dyn T nputProtocol, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let args = Pred ct onServ ceGetBatchPred ct onArgs::read_from_ n_protocol( _prot)?;
    match handler.handle_get_batch_pred ct on(args.batch_request) {
      Ok(handler_return) => {
        let  ssage_ dent = T ssage dent f er::new("getBatchPred ct on", T ssageType::Reply,  ncom ng_sequence_number);
        o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
        let ret = Pred ct onServ ceGetBatchPred ct onResult { result_value: So (handler_return), pred ct on_serv ce_except on: None };
        ret.wr e_to_out_protocol(o_prot)?;
        o_prot.wr e_ ssage_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thr ft::Error::User(usr_err) => {
             f usr_err.downcast_ref::<Pred ct onServ ceExcept on>(). s_so () {
              let err = usr_err.downcast::<Pred ct onServ ceExcept on>().expect("downcast already c cked");
              let ret_err = Pred ct onServ ceGetBatchPred ct onResult{ result_value: None, pred ct on_serv ce_except on: So (*err) };
              let  ssage_ dent = T ssage dent f er::new("getBatchPred ct on", T ssageType::Reply,  ncom ng_sequence_number);
              o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
              ret_err.wr e_to_out_protocol(o_prot)?;
              o_prot.wr e_ ssage_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                Appl cat onError::new(
                  Appl cat onErrorK nd::Unknown,
                  usr_err.to_str ng()
                )
              };
              let  ssage_ dent = T ssage dent f er::new("getBatchPred ct on", T ssageType::Except on,  ncom ng_sequence_number);
              o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
              thr ft::Error::wr e_appl cat on_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.wr e_ ssage_end()?;
              o_prot.flush()
            }
          },
          thr ft::Error::Appl cat on(app_err) => {
            let  ssage_ dent = T ssage dent f er::new("getBatchPred ct on", T ssageType::Except on,  ncom ng_sequence_number);
            o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
            thr ft::Error::wr e_appl cat on_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.wr e_ ssage_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              Appl cat onError::new(
                Appl cat onErrorK nd::Unknown,
                e.to_str ng()
              )
            };
            let  ssage_ dent = T ssage dent f er::new("getBatchPred ct on", T ssageType::Except on,  ncom ng_sequence_number);
            o_prot.wr e_ ssage_beg n(& ssage_ dent)?;
            thr ft::Error::wr e_appl cat on_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.wr e_ ssage_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

 mpl <H: Pred ct onServ ceSyncHandler> TProcessor for Pred ct onServ ceSyncProcessor<H> {
  fn process(&self,  _prot: &mut dyn T nputProtocol, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let  ssage_ dent =  _prot.read_ ssage_beg n()?;
    let res = match &* ssage_ dent.na  {
      "getPred ct on" => {
        self.process_get_pred ct on( ssage_ dent.sequence_number,  _prot, o_prot)
      },
      "getBatchPred ct on" => {
        self.process_get_batch_pred ct on( ssage_ dent.sequence_number,  _prot, o_prot)
      },
       thod => {
        Err(
          thr ft::Error::Appl cat on(
            Appl cat onError::new(
              Appl cat onErrorK nd::Unknown thod,
              format!("unknown  thod {}",  thod)
            )
          )
        )
      },
    };
    thr ft::server::handle_process_result(& ssage_ dent, res, o_prot)
  }
}

//
// Pred ct onServ ceGetPred ct onArgs
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
struct Pred ct onServ ceGetPred ct onArgs {
  request: Pred ct onRequest,
}

 mpl Pred ct onServ ceGetPred ct onArgs {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onServ ceGetPred ct onArgs> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<Pred ct onRequest> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = Pred ct onRequest::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("Pred ct onServ ceGetPred ct onArgs.request", &f_1)?;
    let ret = Pred ct onServ ceGetPred ct onArgs {
      request: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("getPred ct on_args");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("request", TType::Struct, 1))?;
    self.request.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// Pred ct onServ ceGetPred ct onResult
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
struct Pred ct onServ ceGetPred ct onResult {
  result_value: Opt on<Pred ct onResponse>,
  pred ct on_serv ce_except on: Opt on<Pred ct onServ ceExcept on>,
}

 mpl Pred ct onServ ceGetPred ct onResult {
  fn ok_or(self) -> thr ft::Result<Pred ct onResponse> {
     f self.pred ct on_serv ce_except on. s_so () {
      Err(thr ft::Error::User(Box::new(self.pred ct on_serv ce_except on.unwrap())))
    } else  f self.result_value. s_so () {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thr ft::Error::Appl cat on(
          Appl cat onError::new(
            Appl cat onErrorK nd::M ss ngResult,
            "no result rece ved for Pred ct onServ ceGetPred ct on"
          )
        )
      )
    }
  }
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onServ ceGetPred ct onResult> {
     _prot.read_struct_beg n()?;
    let mut f_0: Opt on<Pred ct onResponse> = None;
    let mut f_1: Opt on<Pred ct onServ ceExcept on> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        0 => {
          let val = Pred ct onResponse::read_from_ n_protocol( _prot)?;
          f_0 = So (val);
        },
        1 => {
          let val = Pred ct onServ ceExcept on::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = Pred ct onServ ceGetPred ct onResult {
      result_value: f_0,
      pred ct on_serv ce_except on: f_1,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Pred ct onServ ceGetPred ct onResult");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.result_value {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("result_value", TType::Struct, 0))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.pred ct on_serv ce_except on {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("pred ct onServ ceExcept on", TType::Struct, 1))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// Pred ct onServ ceGetBatchPred ct onArgs
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
struct Pred ct onServ ceGetBatchPred ct onArgs {
  batch_request: BatchPred ct onRequest,
}

 mpl Pred ct onServ ceGetBatchPred ct onArgs {
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onServ ceGetBatchPred ct onArgs> {
     _prot.read_struct_beg n()?;
    let mut f_1: Opt on<BatchPred ct onRequest> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        1 => {
          let val = BatchPred ct onRequest::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    ver fy_requ red_f eld_ex sts("Pred ct onServ ceGetBatchPred ct onArgs.batch_request", &f_1)?;
    let ret = Pred ct onServ ceGetBatchPred ct onArgs {
      batch_request: f_1.expect("auto-generated code should have c cked for presence of requ red f elds"),
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("getBatchPred ct on_args");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
    o_prot.wr e_f eld_beg n(&TF eld dent f er::new("batchRequest", TType::Struct, 1))?;
    self.batch_request.wr e_to_out_protocol(o_prot)?;
    o_prot.wr e_f eld_end()?;
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

//
// Pred ct onServ ceGetBatchPred ct onResult
//

#[der ve(Clone, Debug, Eq, Hash, Ord, Part alEq, Part alOrd)]
struct Pred ct onServ ceGetBatchPred ct onResult {
  result_value: Opt on<BatchPred ct onResponse>,
  pred ct on_serv ce_except on: Opt on<Pred ct onServ ceExcept on>,
}

 mpl Pred ct onServ ceGetBatchPred ct onResult {
  fn ok_or(self) -> thr ft::Result<BatchPred ct onResponse> {
     f self.pred ct on_serv ce_except on. s_so () {
      Err(thr ft::Error::User(Box::new(self.pred ct on_serv ce_except on.unwrap())))
    } else  f self.result_value. s_so () {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thr ft::Error::Appl cat on(
          Appl cat onError::new(
            Appl cat onErrorK nd::M ss ngResult,
            "no result rece ved for Pred ct onServ ceGetBatchPred ct on"
          )
        )
      )
    }
  }
  fn read_from_ n_protocol( _prot: &mut dyn T nputProtocol) -> thr ft::Result<Pred ct onServ ceGetBatchPred ct onResult> {
     _prot.read_struct_beg n()?;
    let mut f_0: Opt on<BatchPred ct onResponse> = None;
    let mut f_1: Opt on<Pred ct onServ ceExcept on> = None;
    loop {
      let f eld_ dent =  _prot.read_f eld_beg n()?;
       f f eld_ dent.f eld_type == TType::Stop {
        break;
      }
      let f eld_ d = f eld_ d(&f eld_ dent)?;
      match f eld_ d {
        0 => {
          let val = BatchPred ct onResponse::read_from_ n_protocol( _prot)?;
          f_0 = So (val);
        },
        1 => {
          let val = Pred ct onServ ceExcept on::read_from_ n_protocol( _prot)?;
          f_1 = So (val);
        },
        _ => {
           _prot.sk p(f eld_ dent.f eld_type)?;
        },
      };
       _prot.read_f eld_end()?;
    }
     _prot.read_struct_end()?;
    let ret = Pred ct onServ ceGetBatchPred ct onResult {
      result_value: f_0,
      pred ct on_serv ce_except on: f_1,
    };
    Ok(ret)
  }
  fn wr e_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thr ft::Result<()> {
    let struct_ dent = TStruct dent f er::new("Pred ct onServ ceGetBatchPred ct onResult");
    o_prot.wr e_struct_beg n(&struct_ dent)?;
     f let So (ref fld_var) = self.result_value {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("result_value", TType::Struct, 0))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
     f let So (ref fld_var) = self.pred ct on_serv ce_except on {
      o_prot.wr e_f eld_beg n(&TF eld dent f er::new("pred ct onServ ceExcept on", TType::Struct, 1))?;
      fld_var.wr e_to_out_protocol(o_prot)?;
      o_prot.wr e_f eld_end()?
    }
    o_prot.wr e_f eld_stop()?;
    o_prot.wr e_struct_end()
  }
}

