package com.tw ter.t  l nes.data_process ng.ad_hoc.earlyb rd_rank ng.model_evaluat on

 mport scala.collect on.GenTraversableOnce

case class Cand dateRecord(t et d: Long, fullScore: Double, earlyScore: Double, served: Boolean)

/**
 * A  tr c that compares scores generated by a "full" pred ct on
 * model to a "l ght" (Earlyb rd) model. T   tr c  s calculated for cand dates
 * from a s ngle request.
 */
sealed tra  Earlyb rdEvaluat on tr c {
  def na : Str ng
  def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double]
}

/**
 * P cks t  set of `k` top cand dates us ng l ght scores, and calculates
 * recall of t se l ght-score based cand dates among set of `k` top cand dates
 * us ng full scores.
 *
 *  f t re are fe r than `k` cand dates, t n   can choose to f lter out requests (w ll
 * lo r value of recall) or keep t m by tr v ally comput ng recall as 1.0.
 */
case class TopKRecall(k:  nt, f lterFe rThanK: Boolean) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"top_${k}_recall${ f (f lterFe rThanK) "_f ltered" else ""}"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
     f (cand dates.s ze <= k) {
       f (f lterFe rThanK) None else So (1.0)
    } else {
      val topFull = cand dates.sortBy(-_.fullScore).take(k)
      val topL ght = cand dates.sortBy(-_.earlyScore).take(k)
      val overlap = topFull.map(_.t et d). ntersect(topL ght.map(_.t et d))
      val truePos = overlap.s ze.toDouble
      So (truePos / k.toDouble)
    }
  }
}

/**
 * Calculates t  probab l y that a random pa r of cand dates w ll be ordered t  sa  by t 
 * full and earlyb rd models.
 *
 * Note: A pa r w h sa  scores for one model and d fferent for t  ot r w ll contr bute 1
 * to t  sum. Pa rs that are str ctly ordered t  sa , w ll contr bute 2.
 *   follows that t  score for a constant model  s 0.5, wh ch  s approx mately equal to a
 * random model as expected.
 */
case object Probab l yOfCorrectOrder ng extends Earlyb rdEvaluat on tr c {

  def fract onOf[A](trav: GenTraversableOnce[A])(p: A => Boolean): Double = {
     f (trav. sEmpty)
      0.0
    else {
      val (numPos, numEle nts) = trav.foldLeft((0, 0)) {
        case ((numPosAcc, numEle ntsAcc), elem) =>
          ( f (p(elem)) numPosAcc + 1 else numPosAcc, numEle ntsAcc + 1)
      }
      numPos.toDouble / numEle nts
    }
  }

  overr de def na : Str ng = "probab l y_of_correct_order ng"

  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
     f (cand dates.s ze < 2)
      None
    else {
      val pa rs = for {
        left <- cand dates. erator
        r ght <- cand dates. erator
         f left != r ght
      } y eld (left, r ght)

      val probab l yOfCorrect = fract onOf(pa rs) {
        case (left, r ght) =>
          (left.fullScore > r ght.fullScore) == (left.earlyScore > r ght.earlyScore)
      }

      So (probab l yOfCorrect)
    }
  }
}

/**
 * L ke `TopKRecall`, but uses `n` % of top cand dates  nstead.
 */
case class TopNPercentRecall(percent: Double) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"top_${percent}_pct_recall"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
    val k = Math.floor(cand dates.s ze * percent).to nt
     f (k > 0) {
      val topFull = cand dates.sortBy(-_.fullScore).take(k)
      val topL ght = cand dates.sortBy(-_.earlyScore).take(k)
      val overlap = topFull.map(_.t et d). ntersect(topL ght.map(_.t et d))
      val truePos = overlap.s ze.toDouble
      So (truePos / k.toDouble)
    } else {
      None
    }
  }
}

/**
 * P cks t  set of `k` top cand dates us ng l ght scores, and calculates
 * recall of selected l ght-score based cand dates among set of actual
 * shown cand dates.
 */
case class ShownT etRecall(k:  nt) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"shown_t et_recall_$k"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
     f (cand dates.s ze <= k) {
      None
    } else {
      val topL ght = cand dates.sortBy(-_.earlyScore).take(k)
      val truePos = topL ght.count(_.served).toDouble
      val allPos = cand dates.count(_.served).toDouble
       f (allPos > 0) So (truePos / allPos)
      else None
    }
  }
}

/**
 * L ke `ShownT etRecall`, but uses `n` % of top cand dates  nstead.
 */
case class ShownT etPercentRecall(percent: Double) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"shown_t et_recall_${percent}_pct"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
    val k = Math.floor(cand dates.s ze * percent).to nt
    val topL ght = cand dates.sortBy(-_.earlyScore).take(k)
    val truePos = topL ght.count(_.served).toDouble
    val allPos = cand dates.count(_.served).toDouble
     f (allPos > 0) So (truePos / allPos)
    else None
  }
}

/**
 * L ke `ShownT etRecall`, but calculated us ng *full* scores. T   s a san y  tr c,
 * because by def n  on t  top full-scored cand dates w ll be served.  f t  value  s
 * < 1, t   s due to t  ranked sect on be ng smaller than k.
 */
case class ShownT etRecallW hFullScores(k:  nt) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"shown_t et_recall_w h_full_scores_$k"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
     f (cand dates.s ze <= k) {
      None
    } else {
      val topFull = cand dates.sortBy(-_.fullScore).take(k)
      val truePos = topFull.count(_.served).toDouble
      val allPos = cand dates.count(_.served).toDouble
       f (allPos > 0) So (truePos / allPos)
      else None
    }
  }
}

/**
 * P cks t  set of `k` top cand dates us ng t  l ght scores, and calculates
 * average full score for t  cand dates.
 */
case class AverageFullScoreForTopL ght(k:  nt) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"average_full_score_for_top_l ght_$k"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
     f (cand dates.s ze <= k) {
      None
    } else {
      val topL ght = cand dates.sortBy(-_.earlyScore).take(k)
      So (topL ght.map(_.fullScore).sum / topL ght.s ze)
    }
  }
}

/**
 * P cks t  set of `k` top cand dates us ng t  l ght scores, and calculates
 * sum of full scores for those. D v des that by sum of `k` top full scores,
 * overall, to get a "score recall".
 */
case class SumScoreRecallForTopL ght(k:  nt) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"sum_score_recall_for_top_l ght_$k"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] = {
     f (cand dates.s ze <= k) {
      None
    } else {
      val sumFullScoresForTopL ght = cand dates.sortBy(-_.earlyScore).take(k).map(_.fullScore).sum
      val sumScoresForTopFull = cand dates.sortBy(-_.fullScore).take(k).map(_.fullScore).sum
      So (sumFullScoresForTopL ght / sumScoresForTopFull)
    }
  }
}

case class HasFe rThanKCand dates(k:  nt) extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"has_fe r_than_${k}_cand dates"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] =
    So ( f (cand dates.s ze <= k) 1.0 else 0.0)
}

case object NumberOfCand dates extends Earlyb rdEvaluat on tr c {
  overr de val na : Str ng = s"number_of_cand dates"
  overr de def apply(cand dates: Seq[Cand dateRecord]): Opt on[Double] =
    So (cand dates.s ze.toDouble)
}
