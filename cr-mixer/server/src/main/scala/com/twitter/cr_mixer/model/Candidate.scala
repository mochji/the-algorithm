package com.tw ter.cr_m xer.model

 mport com.tw ter.contentrecom nder.thr ftscala.T et nfo
 mport com.tw ter.cr_m xer.thr ftscala.L ne em nfo
 mport com.tw ter.s mclusters_v2.common.T et d

sealed tra  Cand date {
  val t et d: T et d

  overr de def hashCode:  nt = t et d.to nt
}

case class T etW hCand dateGenerat on nfo(
  t et d: T et d,
  cand dateGenerat on nfo: Cand dateGenerat on nfo)
    extends Cand date {

  def getS m lar yScore: Double =
    cand dateGenerat on nfo.s m lar yEng ne nfo.score.getOrElse(0.0)
}

case class  n  alCand date(
  t et d: T et d,
  t et nfo: T et nfo,
  cand dateGenerat on nfo: Cand dateGenerat on nfo)
    extends Cand date {

  /** *
   * Get t  S m lar y Score of a T et from  s CG  nfo. For  nstance,
   *  f    s from a Un f edT etBasedS m lar yEng ne, t  score w ll be t    ghted comb ned score
   * And  f    s from a S mClustersANNS m lar yEng ne, t  score w ll be t  SANN score
   */
  def getS m lar yScore: Double =
    cand dateGenerat on nfo.s m lar yEng ne nfo.score.getOrElse(0.0)

  /**
   * T  sa  cand date can be generated by mult ple algor hms.
   * Dur ng blend ng, cand date dedup ng happens.  n order to reta n t  cand dateGenerat on nfo
   * from d fferent algor hms,   attach t m to a l st of potent alReasons.
   */
  def toBlendedCand date(
    potent alReasons: Seq[Cand dateGenerat on nfo],
  ): BlendedCand date = {
    BlendedCand date(
      t et d,
      t et nfo,
      cand dateGenerat on nfo,
      potent alReasons,
    )
  }

  // for exper  ntal purposes only w n bypass ng  nterleave / rank ng
  def toRankedCand date(): RankedCand date = {
    RankedCand date(
      t et d,
      t et nfo,
      0.0, // pred ct on score  s default to 0.0 to  lp d fferent ate that    s a no-op
      cand dateGenerat on nfo,
      Seq(cand dateGenerat on nfo)
    )
  }
}

case class  n  alAdsCand date(
  t et d: T et d,
  l ne em nfo: Seq[L ne em nfo],
  cand dateGenerat on nfo: Cand dateGenerat on nfo)
    extends Cand date {

  /** *
   * Get t  S m lar y Score of a T et from  s CG  nfo. For  nstance,
   *  f    s from a Un f edT etBasedS m lar yEng ne, t  score w ll be t    ghted comb ned score
   * And  f    s from a S mClustersANNS m lar yEng ne, t  score w ll be t  SANN score
   */
  def getS m lar yScore: Double =
    cand dateGenerat on nfo.s m lar yEng ne nfo.score.getOrElse(0.0)

  /**
   * T  sa  cand date can be generated by mult ple algor hms.
   * Dur ng blend ng, cand date dedup ng happens.  n order to reta n t  cand dateGenerat on nfo
   * from d fferent algor hms,   attach t m to a l st of potent alReasons.
   */
  def toBlendedAdsCand date(
    potent alReasons: Seq[Cand dateGenerat on nfo],
  ): BlendedAdsCand date = {
    BlendedAdsCand date(
      t et d,
      l ne em nfo,
      cand dateGenerat on nfo,
      potent alReasons,
    )
  }

  // for exper  ntal purposes only w n bypass ng  nterleave / rank ng
  def toRankedAdsCand date(): RankedAdsCand date = {
    RankedAdsCand date(
      t et d,
      l ne em nfo,
      0.0, // pred ct on score  s default to 0.0 to  lp d fferent ate that    s a no-op
      cand dateGenerat on nfo,
      Seq(cand dateGenerat on nfo)
    )
  }
}

case class BlendedCand date(
  t et d: T et d,
  t et nfo: T et nfo,
  reasonChosen: Cand dateGenerat on nfo,
  potent alReasons: Seq[Cand dateGenerat on nfo])
    extends Cand date {

  /** *
   * Get t  S m lar y Score of a T et from  s CG  nfo. For  nstance,
   *  f    s from a Un f edT etBasedS m lar yEng ne, t  score w ll be t    ghted comb ned score
   * And  f    s from a S mClustersANNS m lar yEng ne, t  score w ll be t  SANN score
   */
  def getS m lar yScore: Double =
    reasonChosen.s m lar yEng ne nfo.score.getOrElse(0.0)

  assert(potent alReasons.conta ns(reasonChosen))

  def toRankedCand date(pred ct onScore: Double): RankedCand date = {
    RankedCand date(
      t et d,
      t et nfo,
      pred ct onScore,
      reasonChosen,
      potent alReasons
    )
  }
}

case class BlendedAdsCand date(
  t et d: T et d,
  l ne em nfo: Seq[L ne em nfo],
  reasonChosen: Cand dateGenerat on nfo,
  potent alReasons: Seq[Cand dateGenerat on nfo])
    extends Cand date {

  /** *
   * Get t  S m lar y Score of a T et from  s CG  nfo. For  nstance,
   *  f    s from a Un f edT etBasedS m lar yEng ne, t  score w ll be t    ghted comb ned score
   * And  f    s from a S mClustersANNS m lar yEng ne, t  score w ll be t  SANN score
   */
  def getS m lar yScore: Double =
    reasonChosen.s m lar yEng ne nfo.score.getOrElse(0.0)

  assert(potent alReasons.conta ns(reasonChosen))

  def toRankedAdsCand date(pred ct onScore: Double): RankedAdsCand date = {
    RankedAdsCand date(
      t et d,
      l ne em nfo,
      pred ct onScore,
      reasonChosen,
      potent alReasons
    )
  }
}

case class RankedCand date(
  t et d: T et d,
  t et nfo: T et nfo,
  pred ct onScore: Double,
  reasonChosen: Cand dateGenerat on nfo,
  potent alReasons: Seq[Cand dateGenerat on nfo])
    extends Cand date {

  /** *
   * Get t  S m lar y Score of a T et from  s CG  nfo. For  nstance,
   *  f    s from a Un f edT etBasedS m lar yEng ne, t  score w ll be t    ghted comb ned score
   * And  f    s from a S mClustersANNS m lar yEng ne, t  score w ll be t  SANN score
   */
  def getS m lar yScore: Double =
    reasonChosen.s m lar yEng ne nfo.score.getOrElse(0.0)

  assert(potent alReasons.conta ns(reasonChosen))
}

case class RankedAdsCand date(
  t et d: T et d,
  l ne em nfo: Seq[L ne em nfo],
  pred ct onScore: Double,
  reasonChosen: Cand dateGenerat on nfo,
  potent alReasons: Seq[Cand dateGenerat on nfo])
    extends Cand date {

  /** *
   * Get t  S m lar y Score of a T et from  s CG  nfo. For  nstance,
   *  f    s from a Un f edT etBasedS m lar yEng ne, t  score w ll be t    ghted comb ned score
   * And  f    s from a S mClustersANNS m lar yEng ne, t  score w ll be t  SANN score
   */
  def getS m lar yScore: Double =
    reasonChosen.s m lar yEng ne nfo.score.getOrElse(0.0)

  assert(potent alReasons.conta ns(reasonChosen))
}

case class Tr pT etW hScore(t et d: T et d, score: Double) extends Cand date
