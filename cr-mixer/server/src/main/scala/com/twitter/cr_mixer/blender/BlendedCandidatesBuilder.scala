package com.tw ter.cr_m xer.blender

 mport com.tw ter.cr_m xer.model.BlendedCand date
 mport com.tw ter.cr_m xer.model.Cand dateGenerat on nfo
 mport com.tw ter.cr_m xer.model. n  alCand date
 mport com.tw ter.s mclusters_v2.common.T et d
 mport scala.collect on.mutable

object BlendedCand datesBu lder {

  /**
   * @param  nputCand dates  nput cand date pr or to  nterleav ng
   * @param  nterleavedCand dates after  nterleav ng. T se t ets are de-dupl cated.
   */
  def bu ld(
     nputCand dates: Seq[Seq[ n  alCand date]],
     nterleavedCand dates: Seq[ n  alCand date]
  ): Seq[BlendedCand date] = {
    val cg nfoLookupMap = bu ldCand dateToCG nfosMap( nputCand dates)
     nterleavedCand dates.map {  nterleavedCand date =>
       nterleavedCand date.toBlendedCand date(cg nfoLookupMap( nterleavedCand date.t et d))
    }
  }

  /**
   * T  sa  t et can be generated by d fferent s ces.
   * T  funct on tells   wh ch Cand dateGenerat on nfo generated a g ven t et
   */
  pr vate def bu ldCand dateToCG nfosMap(
    cand dateSeq: Seq[Seq[ n  alCand date]],
  ): Map[T et d, Seq[Cand dateGenerat on nfo]] = {
    val t et dMap = mutable.HashMap[T et d, Seq[Cand dateGenerat on nfo]]()

    cand dateSeq.foreach { cand dates =>
      cand dates.foreach { cand date =>
        val cand dateGenerat on nfoSeq = {
          t et dMap.getOrElse(cand date.t et d, Seq.empty)
        }
        val cand dateGenerat on nfo = cand date.cand dateGenerat on nfo
        t et dMap.put(
          cand date.t et d,
          cand dateGenerat on nfoSeq ++ Seq(cand dateGenerat on nfo))
      }
    }
    t et dMap.toMap
  }

}
