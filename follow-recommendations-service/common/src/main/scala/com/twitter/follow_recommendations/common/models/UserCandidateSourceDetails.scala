package com.tw ter.follow_recom ndat ons.common.models

 mport com.tw ter.follow_recom ndat ons.logg ng.{thr ftscala => offl ne}
 mport com.tw ter.follow_recom ndat ons.{thr ftscala => t}
 mport com.tw ter. rm .constants.Algor hmFeedbackTokens._
 mport com.tw ter. rm .ml.models.Feature
 mport com.tw ter. rm .model.Algor hm
 mport com.tw ter.product_m xer.core.model.common. dent f er.Cand dateS ce dent f er

/**
 * pr maryCand dateS ce param  s show ng t  cand date s ce that respons ble for generat ng t 
 * cand date, as t  cand date m ght have gone through mult ple cand date s ces to get generated
 * (for example  f   has generated by a compos e s ce).   ghtedCand dateS ceRanker uses t 
 * f eld to do t  sampl ng over cand date s ces. All t  s ces used for generat ng t 
 * cand date ( nclud ng t  pr mary s ce) and t  r correspond ng score ex st  n t 
 * cand dateS ceScores f eld.
 */
case class UserCand dateS ceDeta ls(
  pr maryCand dateS ce: Opt on[Cand dateS ce dent f er],
  cand dateS ceScores: Map[Cand dateS ce dent f er, Opt on[Double]] = Map.empty,
  cand dateS ceRanks: Map[Cand dateS ce dent f er,  nt] = Map.empty,
  addressBook tadata: Opt on[AddressBook tadata] = None,
  cand dateS ceFeatures: Map[Cand dateS ce dent f er, Seq[Feature]] = Map.empty,
) {

  def toThr ft: t.Cand dateS ceDeta ls = {
    t.Cand dateS ceDeta ls(
      cand dateS ceScores = So (cand dateS ceScores.map {
        case ( dent f er, score) =>
          ( dent f er.na , score.getOrElse(0.0d))
      }),
      pr maryS ce = for {
         dent f er <- pr maryCand dateS ce
        algo <- Algor hm.w hNa Opt( dent f er.na )
        feedbackToken <- Algor hmToFeedbackTokenMap.get(algo)
      } y eld feedbackToken
    )
  }

  def toOffl neThr ft: offl ne.Cand dateS ceDeta ls = {
    offl ne.Cand dateS ceDeta ls(
      cand dateS ceScores = So (cand dateS ceScores.map {
        case ( dent f er, score) =>
          ( dent f er.na , score.getOrElse(0.0d))
      }),
      pr maryS ce = for {
         dent f er <- pr maryCand dateS ce
        algo <- Algor hm.w hNa Opt( dent f er.na )
        feedbackToken <- Algor hmToFeedbackTokenMap.get(algo)
      } y eld feedbackToken
    )
  }
}

object UserCand dateS ceDeta ls {
  val algor hmNa Map: Map[Str ng, Algor hm.Value] = Algor hm.values.map {
    algor hmValue: Algor hm.Value =>
      (algor hmValue.toStr ng, algor hmValue)
  }.toMap

  /**
   * T   thod  s used to parse t  cand date s ce of t  cand dates, wh ch  s only passed from
   * t  scoreUserCand dates endpo nt.   create custom cand date s ce  dent f ers wh ch
   * Cand dateAlgor hmS ce w ll read from to hydrate t  algor hm  d feature.
   * cand dateS ceScores w ll not be populated from t  endpo nt, but   add t  convers on for
   * completeness. Note that t  convers on uses t  raw str ng of t  Algor hm rat r than t 
   * ass gned str ngs that   g ve to   own cand date s ces  n t  FRS.
   */
  def fromThr ft(deta ls: t.Cand dateS ceDeta ls): UserCand dateS ceDeta ls = {
    val pr maryCand dateS ce: Opt on[Cand dateS ce dent f er] = for {
      pr maryS ceToken <- deta ls.pr maryS ce
      algo <- TokenToAlgor hmMap.get(pr maryS ceToken)
    } y eld Cand dateS ce dent f er(algo.toStr ng)

    val cand dateS ceScores = for {
      scoreMap <- deta ls.cand dateS ceScores.toSeq
      (na , score) <- scoreMap
      algo <- algor hmNa Map.get(na )
    } y eld {
      Cand dateS ce dent f er(algo.toStr ng) -> So (score)
    }
    val cand dateS ceRanks = for {
      rankMap <- deta ls.cand dateS ceRanks.toSeq
      (na , rank) <- rankMap
      algo <- algor hmNa Map.get(na )
    } y eld {
      Cand dateS ce dent f er(algo.toStr ng) -> rank
    }
    UserCand dateS ceDeta ls(
      pr maryCand dateS ce = pr maryCand dateS ce,
      cand dateS ceScores = cand dateS ceScores.toMap,
      cand dateS ceRanks = cand dateS ceRanks.toMap,
      addressBook tadata = None,
      cand dateS ceFeatures = Map.empty
    )
  }
}
