package com.tw ter.servo.cac 

 mport com.tw ter.ut l.Durat on
 mport scala.collect on.mutable

/**
 * Used to produce d fferently-typed cac s w h t  sa  conf gurat on
 * and potent ally w h shared observat on.
 */
tra  Cac Factory {
  def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*): Cac [K, V]
}

/**
 * Bu lds an  nstance of NullCac .
 */
object NullCac Factory extends Cac Factory {
  val cac  = new NullCac [Noth ng, Noth ng]

  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*): Cac [K, V] =
    cac .as nstanceOf[NullCac [K, V]]
}

/**
 * Bu lds Dec derableCac s, wh ch proxy to one of two cac s bu lt from t 
 * argu nt Cac Factor es depend ng on a dec der value.
 */
case class Dec derableCac Factory(
  pr maryCac Factory: Cac Factory,
  secondaryCac Factory: Cac Factory,
   sAva lable: () => Boolean)
    extends Cac Factory {
  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*) =
    new Dec derableCac (
      pr maryCac Factory(ser al zer, scopes: _*),
      secondaryCac Factory(ser al zer, scopes: _*),
       sAva lable()
    )
}

/**
 * Bu lds M grat ngCac s, wh ch support gradual m grat ons from one cac 
 * to anot r. See M grat ngCac .scala for deta ls.
 */
case class M grat ngCac Factory(cac Factory: Cac Factory, darkCac Factory: Cac Factory)
    extends Cac Factory {
  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*) =
    new M grat ngCac (
      cac Factory(ser al zer, scopes: _*),
      darkCac Factory(ser al zer, scopes: _*)
    )
}

case class ObservableCac Factory(cac Factory: Cac Factory, cac Observer: Cac Observer)
    extends Cac Factory {
  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*) =
    new ObservableCac (cac Factory(ser al zer), cac Observer.scope(scopes: _*))
}

/**
 * Bu lds  n- mory cac s w h ele nts that never exp re.
 */
case class MutableMapCac Factory(
  ser al ze: Boolean = false,
  useSharedCac : Boolean = false,
  keyTransfor rFactory: KeyTransfor rFactory = ToStr ngKeyTransfor rFactory)
    extends Cac Factory {
  lazy val sharedCac  = mkCac 

  def mkCac  = {
    new MutableMapCac [Object, Object](new mutable.HashMap)
  }

  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*) = {
    val cac  =  f (useSharedCac ) sharedCac  else mkCac 
     f (ser al ze) {
      new KeyValueTransform ngCac (
        cac .as nstanceOf[Cac [Str ng, Array[Byte]]],
        ser al zer,
        keyTransfor rFactory()
      )
    } else {
      cac .as nstanceOf[Cac [K, V]]
    }
  }
}

/**
 * Bu lds  n- mory cac s w h TTL'd entr es and LRU ev ct on pol c es.
 */
case class  nProcessLruCac Factory(
  ttl: Durat on,
  lruS ze:  nt,
  ser al ze: Boolean = false,
  useSharedCac : Boolean = false,
  keyTransfor rFactory: KeyTransfor rFactory = ToStr ngKeyTransfor rFactory)
    extends Cac Factory {
  def mkCac  = new Exp r ngLruCac [Object, Object](ttl, lruS ze)
  lazy val sharedCac  = mkCac 

  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*) = {
    val cac  =  f (useSharedCac ) sharedCac  else mkCac 
     f (ser al ze) {
      new KeyValueTransform ngCac (
        cac .as nstanceOf[Cac [Str ng, Array[Byte]]],
        ser al zer,
        keyTransfor rFactory()
      )
    } else {
      cac .as nstanceOf[Cac [K, V]]
    }
  }
}

/**
 * Bu lds  mcac Cac s, wh ch appl es ser al zat on, key-transformat on,
 * and TTL  chan cs to an underly ng  mcac .
 */
case class  mcac Cac Factory(
   mcac :  mcac ,
  ttl: Durat on,
  keyTransfor rFactory: KeyTransfor rFactory = ToStr ngKeyTransfor rFactory)
    extends Cac Factory {
  overr de def apply[K, V](ser al zer: Ser al zer[V], scopes: Str ng*) =
    new  mcac Cac ( mcac , ttl, ser al zer, keyTransfor rFactory[K]())
}

/**
 * Bu lds KeyTransfor rs, wh ch are requ red for construct ng
 * KeyValueTransform ngCac s.
 */
tra  KeyTransfor rFactory {
  def apply[K](): KeyTransfor r[K]
}

/**
 * Bu lds KeyTransfor rs by s mply call t  keys' toStr ng  thods.
 */
object ToStr ngKeyTransfor rFactory extends KeyTransfor rFactory {
  def apply[K]() = new ToStr ngKeyTransfor r[K]()
}

/**
 * Bu lds KeyTransfor rs that pref x all keys generated by an underly ng
 * transfor r w h a str ng.
 */
case class Pref xKeyTransfor rFactory(
  pref x: Str ng,
  del m er: Str ng = constants.Colon,
  underly ng: KeyTransfor rFactory = ToStr ngKeyTransfor rFactory)
    extends KeyTransfor rFactory {
  def apply[K]() = new Pref xKeyTransfor r[K](pref x, del m er, underly ng[K]())
}
