package com.tw ter.servo.cac 

 mport com.google.common.pr m  ves.{ nts, Longs}
 mport com.tw ter.f nagle.thr ft.Protocols
 mport com.tw ter. o.Buf
 mport com.tw ter.scrooge.{Thr ftStruct, Thr ftStructCodec, Thr ftStructSer al zer}
 mport com.tw ter.servo.ut l.Transfor r
 mport com.tw ter.ut l.{T   => Ut lT  , Try}
 mport java. o.{ByteArray nputStream, ByteArrayOutputStream}
 mport java.n o.ByteBuffer
 mport org.apac .thr ft.TBase
 mport org.apac .thr ft.protocol.{TCompactProtocol, TProtocolFactory}
 mport org.apac .thr ft.transport.T OStreamTransport

object Ser al zers { self =>
  val CompactProtocolFactory = new TCompactProtocol.Factory
  val EmptyByteArray = Array.empty[Byte]

  val Un  = Transfor r[Un , Array[Byte]](_ => EmptyByteArray, _ => ())

  object Long {
    val S mple = Transfor r[Long, Array[Byte]](Longs.toByteArray, Longs.fromByteArray)
  }

  object Cac dLong {
    val Compact: Ser al zer[Cac d[Long]] =
      new Cac dSer al zer(self.Long.S mple, CompactProtocolFactory)
  }

  object SeqLong {
    val S mple: Ser al zer[Seq[Long]] = new SeqSer al zer(self.Long.S mple, 8)
  }

  object Cac dSeqLong {
    val Compact: Ser al zer[Cac d[Seq[Long]]] =
      new Cac dSer al zer(self.SeqLong.S mple, CompactProtocolFactory)
  }

  object  nt {
    val S mple = Transfor r[ nt, Array[Byte]]( nts.toByteArray,  nts.fromByteArray)
  }

  object Cac d nt {
    val Compact: Ser al zer[Cac d[ nt]] =
      new Cac dSer al zer(self. nt.S mple, CompactProtocolFactory)
  }

  object Seq nt {
    val S mple: Ser al zer[Seq[ nt]] = new SeqSer al zer(self. nt.S mple, 4)
  }

  object Cac dSeq nt {
    val Compact: Ser al zer[Cac d[Seq[ nt]]] =
      new Cac dSer al zer(self.Seq nt.S mple, CompactProtocolFactory)
  }

  object Str ng {
    val Utf8: Ser al zer[Str ng] = Transfor r.Utf8ToBytes
  }

  object Cac dStr ng {
    val Compact: Ser al zer[Cac d[Str ng]] =
      new Cac dSer al zer(self.Str ng.Utf8, CompactProtocolFactory)
  }

  object SeqStr ng {
    val Utf8: Ser al zer[Seq[Str ng]] = new SeqSer al zer(self.Str ng.Utf8)
  }

  object Cac dSeqStr ng {
    val Compact: Ser al zer[Cac d[Seq[Str ng]]] =
      new Cac dSer al zer(self.SeqStr ng.Utf8, CompactProtocolFactory)
  }

  /**
   *   take care not to alter t  buffer so that t  convers on can
   * safely be used mult ple t  s w h t  sa  buffer, and that
   * ot r threads cannot v ew ot r states of t  buffer.
   */
  pr vate[t ] def byteBufferToArray(b: ByteBuffer): Array[Byte] = {
    val a = new Array[Byte](b.rema n ng)
    b.dupl cate.get(a)
    a
  }

  /**
   * Convert bet en a ByteBuffer and an Array of bytes. T 
   * convers on to Array[Byte] makes a copy of t  data, wh le t 
   * reverse convers on just wraps t  array.
   */
  val ArrayByteBuffer: Transfor r[Array[Byte], ByteBuffer] =
    Transfor r(ByteBuffer.wrap(_: Array[Byte]), byteBufferToArray)

  val ArrayByteBuf: Transfor r[Array[Byte], Buf] =
    Transfor r(Buf.ByteArray.Shared.apply, Buf.ByteArray.Shared.extract)

  /**
   *  somorp m bet en T   and Long. T  Long represents t  number
   * of nanoseconds s nce t  epoch.
   */
  val T  Nanos: Transfor r[Ut lT  , Long] =
    Transfor r.pure[Ut lT  , Long](_. nNanoseconds, Ut lT  .fromNanoseconds)

  /**
   * Transfor r from T   to Array[Byte] always succeeds. T   nverse
   * transform throws BufferUnderflowExcept on  f t  buffer  s less
   * than e ght bytes  n length.  f    s greater than e ght bytes,
   * t  later bytes are d scarded.
   */
  // T   s lazy because  f    s not,   may be  n  al zed before
  // Long.S mple.  n that case, Long.S mple w ll be null at
  //  n  al zat on t  , and w ll be captured  re. Unfortunately,
  // t   s dependent on t  order of class  n  al zat on, wh ch may
  // vary bet en runs of a program.
  lazy val T  : Ser al zer[Ut lT  ] = T  Nanos andT n Long.S mple
}

/**
 * A Ser al zer for Thr ft structs generated by Scrooge.
 *
 * @param codec used to encode and decode structs for a g ven protocol
 * @param protocolFactory def nes t  ser al zat on protocol to be used
 */
class Thr ftSer al zer[T <: Thr ftStruct](
  val codec: Thr ftStructCodec[T],
  val protocolFactory: TProtocolFactory)
    extends Ser al zer[T]
    w h Thr ftStructSer al zer[T] {
  overr de def to(obj: T): Try[Array[Byte]] = Try(toBytes(obj))
  overr de def from(bytes: Array[Byte]): Try[T] = Try(fromBytes(bytes))
}

/**
 * A Ser al zer for Thr ft structs generated by t  Apac  code generator.
 *
 * @param tFactory a factory for Thr ft-def ned objects of type T. Objects
 *        y elded by t  factory are read  nto and returned dur ng
 *        deser al zat on.
 *
 * @param protocolFactory def nes t  ser al zat on protocol to be used
 */
class TBaseSer al zer[T <: TBase[_, _]](tFactory: () => T, protocolFactory: TProtocolFactory)
    extends Ser al zer[T] {
  overr de def to(obj: T): Try[Array[Byte]] = Try {
    val baos = new ByteArrayOutputStream
    obj.wr e(protocolFactory.getProtocol(new T OStreamTransport(baos)))
    baos.toByteArray
  }

  overr de def from(bytes: Array[Byte]): Try[T] = Try {
    val obj = tFactory()
    val stream = new ByteArray nputStream(bytes)
    obj.read(protocolFactory.getProtocol(new T OStreamTransport(stream)))
    obj
  }
}

object Cac dSer al zer {
  def b nary[T](valueSer al zer: Ser al zer[T]): Cac dSer al zer[T] =
    new Cac dSer al zer(valueSer al zer, Protocols.b naryFactory())

  def compact[T](valueSer al zer: Ser al zer[T]): Cac dSer al zer[T] =
    new Cac dSer al zer(valueSer al zer, new TCompactProtocol.Factory)
}

/**
 * A Ser al zer of Cac d object.
 *
 * @param valueSer al zer an underly ng ser al zer of t  values to be cac d.
 * @param protocolFactory def nes t  ser al zat on protocol to be used
 */
class Cac dSer al zer[T](valueSer al zer: Ser al zer[T], protocolFactory: TProtocolFactory)
    extends Ser al zer[Cac d[T]] {
  pr vate[t ] val underly ng = new Thr ftSer al zer(Cac dValue, protocolFactory)

  overr de def to(cac d: Cac d[T]): Try[Array[Byte]] =
    underly ng.to(cac d.toCac dValue(valueSer al zer))

  pr vate[t ] val asCac d: Cac dValue => Cac d[T] =
    t => Cac d(t, valueSer al zer)

  overr de def from(bytes: Array[Byte]): Try[Cac d[T]] =
    underly ng.from(bytes).map(asCac d)
}
