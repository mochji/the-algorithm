package com.tw ter.t etyp e
package conf g

 mport com.tw ter.ads. nternal.pcl.serv ce.CallbackPromotedContentLogger
 mport com.tw ter.ads.logg ngcl ent.AdsLogg ngCl ent
 mport com.tw ter.adserver.thr ftscala.AdCallbackEvent
 mport com.tw ter.convers ons.Durat onOps._
 mport com.tw ter.convers ons.PercentOps._
 mport com.tw ter.conta ner.{thr ftscala => ccs}
 mport com.tw ter.deferredrpc.cl ent.DeferredThr ftServ ce
 mport com.tw ter.deferredrpc.thr ft.Datacenter
 mport com.tw ter.deferredrpc.thr ft.DeferredRPC
 mport com.tw ter.deferredrpc.thr ft.Target
 mport com.tw ter.esc rb rd.thr ftscala.T etEnt yAnnotat onServ ce$F nagleCl ent
 mport com.tw ter.esc rb rd.thr ftscala.{
  T etEnt yAnnotat onServ ce => T etEnt yAnnotat onScrooge face
}
 mport com.tw ter.eventbus.cl ent.EventBusPubl s r
 mport com.tw ter.eventbus.cl ent.EventBusPubl s rBu lder
 mport com.tw ter.expandodo.thr ftscala.CardsServ ce$F nagleCl ent
 mport com.tw ter.expandodo.thr ftscala.{CardsServ ce => CardsScrooge face}
 mport com.tw ter.f nagle._
 mport com.tw ter.f nagle.bu lder.Cl entBu lder
 mport com.tw ter.f nagle.cl ent.Transporter
 mport com.tw ter.f nagle.factory.T  outFactory
 mport com.tw ter.f nagle.l veness.Fa lureAccrualFactory
 mport com.tw ter.f nagle.loadbalancer.Balancers
 mport com.tw ter.f nagle.mtls.aut nt cat on.EmptyServ ce dent f er
 mport com.tw ter.f nagle.mtls.cl ent.MtlsCl entBu lder._
 mport com.tw ter.f nagle.mtls.cl ent.MtlsStackCl ent._
 mport com.tw ter.f nagle.part  on ng.param
 mport com.tw ter.f nagle.serv ce.T  outF lter.PropagateDeadl nes
 mport com.tw ter.f nagle.serv ce._
 mport com.tw ter.f nagle.ssl.Opportun st cTls
 mport com.tw ter.f nagle.stats.StatsRece ver
 mport com.tw ter.f nagle.thr ft.Thr ftCl entRequest
 mport com.tw ter.f nagle.thr ftmux. thodBu lder
 mport com.tw ter.f nagle.trac ng.DefaultTracer
 mport com.tw ter.flockdb.cl ent.thr ftscala.FlockDB
 mport com.tw ter.flockdb.cl ent.FlockResponse
 mport com.tw ter.flockdb.cl ent.TFlockCl ent
 mport com.tw ter.flockdb.cl ent.UserT  l neGraph
 mport com.tw ter.geoduck.backend.hydrat on.thr ftscala.{Hydrat on => GeoduckHydrat on}
 mport com.tw ter.geoduck.backend.relevance.thr ftscala.Relevance
 mport com.tw ter.geoduck.backend.relevance.thr ftscala.Relevance$F nagleCl ent
 mport com.tw ter.geoduck.backend.relevance.thr ftscala.RelevanceContext
 mport com.tw ter.geoduck.serv ce.common.cl entmodules.GeoduckGeohashLocate
 mport com.tw ter.geoduck.thr ftscala.ReverseGeocoder
 mport com.tw ter.geoduck.ut l.serv ce.GeoduckLocate
 mport com.tw ter.g zmoduck.thr ftscala.UserServ ce
 mport com.tw ter.hash ng.KeyHas r
 mport com.tw ter.l m er.cl ent.L m erCl entFactory
 mport com.tw ter. d a nfo.server.thr ftscala. d a nfoServ ce$F nagleCl ent
 mport com.tw ter. d a nfo.server.thr ftscala.{ d a nfoServ ce =>  d a nfoScrooge face}
 mport com.tw ter. rl n.thr ftscala.UserRolesServ ce
 mport com.tw ter.passb rd.thr ftscala.Passb rdServ ce
 mport com.tw ter.passb rd.thr ftscala.Passb rdServ ce$F nagleCl ent
 mport com.tw ter.serv ce.gen.scarecrow.thr ftscala.ScarecrowServ ce$F nagleCl ent
 mport com.tw ter.serv ce.gen.scarecrow.thr ftscala.{ScarecrowServ ce => ScarecrowScrooge face}
 mport com.tw ter.serv ce.talon.thr ftscala.Talon$F nagleCl ent
 mport com.tw ter.serv ce.talon.thr ftscala.{Talon => TalonScrooge face}
 mport com.tw ter.snowflake.cl ent.SnowflakeCl ent
 mport com.tw ter.snowflake.thr ftscala.Snowflake
 mport com.tw ter.soc algraph.thr ftscala.Soc alGraphServ ce$F nagleCl ent
 mport com.tw ter.soc algraph.thr ftscala.{Soc alGraphServ ce => Soc alGraphScrooge face}
 mport com.tw ter.storage.cl ent.manhattan.kv.Exper  nts
 mport com.tw ter.storage.cl ent.manhattan.kv.ManhattanKVCl ent
 mport com.tw ter.storage.cl ent.manhattan.kv.ManhattanKVCl entMtlsParams
 mport com.tw ter.storage.cl ent.manhattan.kv.NoMtlsParams
 mport com.tw ter.strato.cl ent.Strato
 mport com.tw ter.strato.cl ent.{Cl ent => StratoCl ent}
 mport com.tw ter.t  l neserv ce.fanout.thr ftscala.FanoutServ ce
 mport com.tw ter.t  l neserv ce.fanout.thr ftscala.FanoutServ ce$F nagleCl ent
 mport com.tw ter.t  l neserv ce.{thr ftscala => tls}
 mport com.tw ter.t etyp e.backends._
 mport com.tw ter.t etyp e.cl ent_ d.Cl ent d lper
 mport com.tw ter.t etyp e. d a. d aCl ent
 mport com.tw ter.t etyp e.serv ce.Repl cat ngT etServ ce.GatedRepl cat onCl ent
 mport com.tw ter.t etyp e.storage.ManhattanT etStorageCl ent
 mport com.tw ter.t etyp e.storage.T etStorageCl ent
 mport com.tw ter.t etyp e.store._
 mport com.tw ter.t etyp e.thr ftscala.DeleteLocat onData
 mport com.tw ter.t etyp e.thr ftscala.Ret etArch valEvent
 mport com.tw ter.t etyp e.thr ftscala.T etEvent
 mport com.tw ter.t etyp e.thr ftscala.T etServ ce nternal$F nagleCl ent
 mport com.tw ter.user_ mage_serv ce.thr ftscala.User mageServ ce$F nagleCl ent
 mport com.tw ter.user_ mage_serv ce.thr ftscala.{User mageServ ce => User mageScrooge face}
 mport com.tw ter.ut l.Throw
 mport com.tw ter.ut l.T  r
 mport com.tw ter.ut l.{T  outExcept on => Ut lT  outExcept on}
 mport scala.ut l.Random

tra  BackendCl ents {

  /** returns all t  f nagle.Na s created wh le bu ld ng cl ents */
  def referencedNa s: Seq[Na ]

  val asyncRetryT etServ ce: Thr ftT etServ ce
  val asyncT etDelet onServ ce: Thr ftT etServ ce
  val asyncT etServ ce: Thr ftT etServ ce
  val conf gBus: Conf gBus
  val creat vesConta nerServ ce: Creat vesConta nerServ ce
  val darkTraff cCl ent: Serv ce[Array[Byte], Array[Byte]]
  val deleteLocat onDataPubl s r: EventBusPubl s r[DeleteLocat onData]
  val esc rb rd: Esc rb rd
  val expandodo: Expandodo
  val fanoutServ ceCl ent: FanoutServ ce. thodPerEndpo nt
  val geoHydrat onLocate: GeoduckLocate
  val geoRelevance: Relevance. thodPerEndpo nt
  val geoScrubEventStore: GeoScrubEventStore
  val geoduckGeohashLocate: GeoduckGeohashLocate
  val g zmoduck: G zmoduck
  val gn pEnr c rator: Gn pEnr c rator
  val guano: Guano
  val l m erServ ce: L m erServ ce
  val lowQoSRepl cat onCl ents: Seq[GatedRepl cat onCl ent]
  val  d aCl ent:  d aCl ent
  val  d a nfoServ ce:  d a nfoServ ce
  val  mcac Cl ent:  mcac d.Cl ent
  val  rl n: UserRolesServ ce. thodPerEndpo nt
  val passb rdCl ent: Passb rdServ ce. thodPerEndpo nt
  val repl cat onCl ent: Thr ftT etServ ce
  val ret etArch valEventPubl s r: EventBusPubl s r[Ret etArch valEvent]
  val scarecrow: Scarecrow
  val snowflakeCl ent: SnowflakeCl ent.SnowflakeCl ent
  val soc alGraphServ ce: Soc alGraphServ ce
  val stratoserverCl ent: StratoCl ent
  val talon: Talon
  val tflockReadCl ent: TFlockCl ent
  val tflockWr eCl ent: TFlockCl ent
  val t  l neServ ce: T  l neServ ce
  val t etEventsPubl s r: EventBusPubl s r[T etEvent]
  val t etStorageCl ent: T etStorageCl ent
  val user mageServ ce: User mageServ ce
  val callbackPromotedContentLogger: CallbackPromotedContentLogger
}

/**
 * default  mple ntat on of BackendCl ents that connects to real, remote
 * backend serv ces.
 */
object BackendCl ents {
  // for most serv ces, t etyp e typ cally ma nta ns only a s ngle connect on to
  // each host  n t  cluster, and that  s enough for normal steady-state work.
  // to prevent ddos' ng backends dur ng unusual traff c  nfluxes,   set t  host
  // connect on l m  to be 2-3x t  steady-state da ly peak, g v ng plenty of  ad
  // room but w hout allow ng an excess ve number of connect ons.
  pr vate val defaultHostConnect onL m  = 3

  // 100ms  s greater than most gc pauses; smaller values cause more t  outs
  pr vate val defaultConnectT  out = 100.m ll seconds
  // tcpConnect t  out  s less than half of defaultConnectT  out, to allow at least
  // two tr es (except w n t re  s a GC pause)
  pr vate val defaultTcpConnectT  out = 20.m ll seconds

  pr vate val Wr eExcept onsOnly: Part alFunct on[Try[Noth ng], Boolean] =
    RetryPol cy.Wr eExcept onsOnly

  pr vate val ClosedExcept onsOnly: Part alFunct on[Try[Noth ng], Boolean] = {
    case Throw(_: ChannelClosedExcept on) => true
  }

  pr vate val T  outExcept onsOnly: Part alFunct on[Try[Noth ng], Boolean] = {
    case Throw(_: T  outExcept on) => true
    case Throw(_: Ut lT  outExcept on) => true
  }

  pr vate val NoBackoff = Backoff.const(0.second)

  pr vate def retry(wr eExcept ons:  nt = 100, closedExcept ons:  nt = 2, t  outs:  nt = 0) =
    RetryPol cy.comb ne(
      RetryPol cy.backoff(NoBackoff.take(wr eExcept ons))(Wr eExcept onsOnly),
      RetryPol cy.backoff(NoBackoff.take(closedExcept ons))(ClosedExcept onsOnly),
      RetryPol cy.backoff(NoBackoff.take(t  outs))(T  outExcept onsOnly)
    )

   mpl c  val warmup: Warmup[BackendCl ents] = {
    // Use a random str ng so that t  keys are l kely to hash to
    // d fferent  mcac   nstances. Request mult ple keys at a t   so
    // that   don't cons der t  backend warm just because   can get a
    // bunch of successful responses to one cac .
    val cac Get = (_:  mcac d.Cl ent).get(Seq.f ll(20)(Random.nextLong.toStr ng))

    Warmup
      .empty[BackendCl ents]
      .warmF eld(_.expandodo)
      .warmF eld(_.g zmoduck)
      .warmF eld(_. mcac Cl ent)(Warmup(" mcac ")(cac Get))
      .warmF eld(_.talon)
      .warmF eld(_.t etStorageCl ent)(Warmup("t etstorage")(_.p ng()))
      .warmF eld(_.tflockReadCl ent)(Warmup("tflock")(_.conta ns(UserT  l neGraph, 0, 0)))
      .warmF eld(_.scarecrow)
      .warmF eld(_.soc alGraphServ ce)
      .warmF eld(_.t  l neServ ce)
      .warmF eld(_.geoRelevance)(Warmup("geo_relevance")(_.placeSearch(RelevanceContext())))
  }

  def apply(
    sett ngs: T etServ ceSett ngs,
    dec derGates: T etyp eDec derGates,
    statsRece ver: StatsRece ver,
    hostStatsRece ver: StatsRece ver,
    t  r: T  r,
    cl ent d lper: Cl ent d lper,
  ): BackendCl ents = {
    val thr ftCl ent d = sett ngs.thr ftCl ent d
    val tracer = DefaultTracer

    val env = sett ngs.env.toStr ng
    val zone = sett ngs.zone
    val log = Logger(getClass)
    val backendsScope = statsRece ver.scope("backends")

    /** a Seq bu lder of f nagle.Na s loaded v a getNa  */
    val referencedNa sBu lder = Seq.newBu lder[Na ]

    /** t  default set of except ons   bel eve are safe for T etyp e to retry */
    val defaultResponseClass f er: ResponseClass f er =
      ResponseClass f er.RetryOnChannelClosed.orElse(ResponseClass f er.RetryOnT  out)

    /**
     * Resolve a str ng  nto a F nagle Na  and record  
     *  n referencedNa s.
     */
    def eval(address: Str ng): Na  = {
      val na  = Resolver.eval(address)
      referencedNa sBu lder += na 
      na 
    }

    def backendContext(na : Str ng) =
      Backend.Context(t  r, backendsScope.scope(na ))

    // by default, retr es on most except ons (see defaultRetryExcept ons).   f an rpc  s not
    //  dempotent,   should use a d fferent retry pol cy.
    def cl entBu lder(na : Str ng) = {
      Cl entBu lder()
        .na (na )
        .reportTo(statsRece ver)
        .reportHostStats(hostStatsRece ver)
        .tracer(tracer)
        .daemon(true)
        .tcpConnectT  out(defaultTcpConnectT  out)
        .connectT  out(defaultConnectT  out)
        .retryPol cy(retry())
    }

    def thr ftMuxCl entBu lder(na : Str ng, address: Str ng, clazz: Class[_]) = {
      cl entBu lder(na )
        .stack(
          Thr ftMux.cl ent
            .w hCl ent d(thr ftCl ent d)
            .w hOpportun st cTls(Opportun st cTls.Requ red)
            .w hServ ceClass(clazz))
        .loadBalancer(balancer())
        .dest(eval(address))
        .mutualTls(sett ngs.serv ce dent f er)
    }

    //   base Thr ftMux.Cl ent
    // Prefer us ng thr ftMux thodBu lder below but
    // can be used to bu ld custom cl ents (re: darkTraff cCl ent)
    def thr ftMuxCl ent(na : Str ng, propagateDeadl nes: Boolean = true): Thr ftMux.Cl ent = {
      Thr ftMux.cl ent
        .w hCl ent d(thr ftCl ent d)
        .w hLabel(na )
        .w hStatsRece ver(statsRece ver)
        .w hTracer(tracer)
        .w hTransport.connectT  out(defaultTcpConnectT  out)
        .w hSess on.acqu s  onT  out(defaultConnectT  out)
        .w hMutualTls(sett ngs.serv ce dent f er)
        .w hOpportun st cTls(Opportun st cTls.Requ red)
        .conf gured(PropagateDeadl nes(enabled = propagateDeadl nes))
    }

    //  f an endpo nt  s non- dempotent   should add .non dempotent and
    // leave off any ResponseClass f ers (  w ll remove any placed before but not after)
    //  f    s unequ vocally  dempotent   should add . dempotent and
    // leave off any ResponseClass f ers (  w ll retry on all Throws).  T  w ll also
    // enable backup requests
    def thr ftMux thodBu lder(
      na : Str ng,
      dest: Str ng,
    ):  thodBu lder = {
      thr ftMuxCl ent(na )
        .w hLoadBalancer(balancer(m nAperture = 2))
        . thodBu lder(dest)
        .w hRetryForClass f er(defaultResponseClass f er)
        .w hT  outTotal(2.seconds) // total t  out  nclud ng 1st attempt and up to 2 retr es
    }

    def balancer(m nAperture:  nt = 2) = Balancers.aperture(m nAperture = m nAperture)

    val eventBusPubl s rBu lder =
      EventBusPubl s rBu lder()
        .dest(eval("/s/eventbus/prov s on ng"))
        .cl ent d(sett ngs.thr ftCl ent d)
        // eventbus stats are furt r scoped by stream, so put all
        // publ s rs under t  sa  stats na space
        .statsRece ver(backendsScope.scope("event_bus"))
        // T  makes t  underly ng kps-cl ent to be resolved over W lyNs vs DNS
        .serv ce dent f er(sett ngs.serv ce dent f er)

    new BackendCl ents {
      def referencedNa s: Seq[Na ] = referencedNa sBu lder.result()

      val  mcac Cl ent:  mcac d.Cl ent =
         mcac d.cl ent
          .w hMutualTls(sett ngs.serv ce dent f er)
          .connect onsPerEndpo nt(2)
          .conf gured(param.KeyHas r(KeyHas r.FNV1_32))
          .conf gured(Transporter.ConnectT  out(100.m ll seconds))
          .conf gured(T  outF lter.Param(200.m ll seconds))
          .conf gured(T  outFactory.Param(200.m ll seconds))
          .conf gured(param.EjectFa ledHost(false))
          .conf gured(Fa lureAccrualFactory.Param(numFa lures = 20, markDeadFor = 30.second))
          .conf gured(
            Pend ngRequestF lter.Param(l m  = So (sett ngs.cac Cl entPend ngRequestL m ))
          )
          .f ltered(new  mcac Except onLogg ngF lter)
          .newR chCl ent(dest = eval(sett ngs.t mcac Dest), label = " mcac ")

      /* cl ents */
      val t etStorageCl ent: T etStorageCl ent =
        Manhattan.fromCl ent(
          new ManhattanT etStorageCl ent(
            sett ngs.t etStorageConf g,
            statsRece ver = backendsScope.scope("t et_storage"),
            cl ent d lper = cl ent d lper,
          )
        )

      val soc alGraphServ ce: Soc alGraphServ ce = {
        val f nagleCl ent =
          new Soc alGraphServ ce$F nagleCl ent(
            thr ftMuxCl entBu lder(
              "soc algraph",
              "/s/soc algraph/soc algraph",
              classOf[Soc alGraphScrooge face. thodPerEndpo nt]
            ).loadBalancer(Balancers.aperturePeakEwma(m nAperture = 16))
              .bu ld()
          )

        sett ngs.soc alGraphSev ceConf g(
          Soc alGraphServ ce.fromCl ent(f nagleCl ent),
          backendContext("soc algraph")
        )
      }

      val tflockCl ent =
        new FlockDB.F nagledCl ent(
          thr ftMuxCl entBu lder("tflock", "/s/tflock/tflock", classOf[FlockDB. thodPerEndpo nt])
            .loadBalancer(balancer(m nAperture = 5))
            .responseClass f er(FlockResponse.class f er)
            .bu ld(),
          serv ceNa  = "tflock",
          stats = statsRece ver
        )

      val tflockReadCl ent: TFlockCl ent =
        sett ngs.tflockReadConf g(tflockCl ent, backendContext("tflock"))

      val tflockWr eCl ent: TFlockCl ent =
        sett ngs.tflockWr eConf g(tflockCl ent, backendContext("tflock"))

      val g zmoduck: G zmoduck = {
        val cl entBu lder =
          thr ftMuxCl entBu lder(
            "g zmoduck",
            "/s/g zmoduck/g zmoduck",
            classOf[UserServ ce. thodPerEndpo nt])
            .loadBalancer(balancer(m nAperture = 63))
        val mb =  thodBu lder
          .from(cl entBu lder)
          . dempotent(maxExtraLoad = 1.percent)
          .serv cePerEndpo nt[UserServ ce.Serv cePerEndpo nt]

        val g zmoduckCl ent = Thr ftMux.Cl ent. thodPerEndpo nt(mb)
        sett ngs.g zmoduckConf g(G zmoduck.fromCl ent(g zmoduckCl ent), backendContext("g zmoduck"))
      }

      val  rl n: UserRolesServ ce. thodPerEndpo nt = {
        val thr ftCl ent = thr ftMux thodBu lder(" rl n", "/s/ rl n/ rl n")
          .w hT  outPerRequest(100.m ll seconds)
          .w hT  outTotal(400.m ll seconds)
          . dempotent(0.01)
          .serv cePerEndpo nt[UserRolesServ ce.Serv cePerEndpo nt]

        Thr ftMux.Cl ent. thodPerEndpo nt(thr ftCl ent)
      }

      val talon: Talon = {
        val talonCl ent =
          new Talon$F nagleCl ent(
            thr ftMuxCl entBu lder(
              "talon",
              "/s/talon/backend",
              classOf[TalonScrooge face. thodPerEndpo nt])
              .bu ld()
          )

        sett ngs.talonConf g(Talon.fromCl ent(talonCl ent), backendContext("talon"))
      }

      val guano = Guano()

      val  d a nfoServ ce:  d a nfoServ ce = {
        val f nagleCl ent =
          new  d a nfoServ ce$F nagleCl ent(
            thr ftMuxCl entBu lder(
              " d a nfo",
              "/s/photurkey/ d a nfo",
              classOf[ d a nfoScrooge face. thodPerEndpo nt])
              .loadBalancer(balancer(m nAperture = 75))
              .bu ld()
          )

        sett ngs. d a nfoServ ceConf g(
           d a nfoServ ce.fromCl ent(f nagleCl ent),
          backendContext(" d a nfo")
        )
      }

      val user mageServ ce: User mageServ ce = {
        val f nagleCl ent =
          new User mageServ ce$F nagleCl ent(
            thr ftMuxCl entBu lder(
              "user mage",
              "/s/user- mage-serv ce/u s",
              classOf[User mageScrooge face. thodPerEndpo nt])
              .bu ld()
          )

        sett ngs.user mageServ ceConf g(
          User mageServ ce.fromCl ent(f nagleCl ent),
          backendContext("user mage")
        )
      }

      val  d aCl ent:  d aCl ent =
         d aCl ent.fromBackends(
          user mageServ ce = user mageServ ce,
           d a nfoServ ce =  d a nfoServ ce
        )

      val t  l neServ ce: T  l neServ ce = {
        val t  l neServ ceCl ent =
          new tls.T  l neServ ce$F nagleCl ent(
            thr ftMuxCl entBu lder(
              "t  l neServ ce",
              "/s/t  l neserv ce/t  l neserv ce",
              classOf[tls.T  l neServ ce. thodPerEndpo nt])
              .loadBalancer(balancer(m nAperture = 13))
              .bu ld()
          )

        sett ngs.t  l neServ ceConf g(
          T  l neServ ce.fromCl ent(t  l neServ ceCl ent),
          backendContext("t  l neServ ce")
        )
      }

      val expandodo: Expandodo = {
        val cardsServ ceCl ent =
          new CardsServ ce$F nagleCl ent(
            thr ftMuxCl entBu lder(
              "expandodo",
              "/s/expandodo/server",
              classOf[CardsScrooge face. thodPerEndpo nt])
              .loadBalancer(balancer(m nAperture = 6))
              .bu ld()
          )

        sett ngs.expandodoConf g(
          Expandodo.fromCl ent(cardsServ ceCl ent),
          backendContext("expandodo")
        )
      }

      val creat vesConta nerServ ce: Creat vesConta nerServ ce = {
        val mb = thr ftMux thodBu lder(
          "creat vesConta nerServ ce",
          "/s/creat ves-conta ner/creat ves-conta ner",
        ).w hT  outTotal(300.m ll seconds)
          . dempotent(maxExtraLoad = 1.percent)
          .serv cePerEndpo nt[ccs.Creat vesConta nerServ ce.Serv cePerEndpo nt]

        sett ngs.creat vesConta nerServ ceConf g(
          Creat vesConta nerServ ce.fromCl ent(ccs.Creat vesConta nerServ ce. thodPerEndpo nt(mb)),
          backendContext("creat vesConta nerServ ce")
        )
      }

      val scarecrow: Scarecrow = {
        val scarecrowCl ent = new ScarecrowServ ce$F nagleCl ent(
          thr ftMuxCl entBu lder(
            "scarecrow",
            "/s/abuse/scarecrow",
            classOf[ScarecrowScrooge face. thodPerEndpo nt])
            .loadBalancer(balancer(m nAperture = 6))
            .bu ld(),
          serv ceNa  = "scarecrow",
          stats = statsRece ver
        )

        sett ngs.scarecrowConf g(Scarecrow.fromCl ent(scarecrowCl ent), backendContext("scarecrow"))
      }

      val snowflakeCl ent: Snowflake. thodPerEndpo nt = {
        eval("/s/snowflake/snowflake") // eagerly resolve t  serverset
        val mb = thr ftMux thodBu lder(
          "snowflake",
          "/s/snowflake/snowflake"
        ).w hT  outTotal(300.m ll seconds)
          .w hT  outPerRequest(100.m ll seconds)
          . dempotent(maxExtraLoad = 1.percent)

        SnowflakeCl ent.snowflakeCl ent(mb)
      }

      val deferredRpcCl ent =
        new DeferredRPC.F nagledCl ent(
          thr ftMuxCl entBu lder(
            "deferredrpc",
            "/s/kafka-shared/krpc-server-ma n",
            classOf[DeferredRPC. thodPerEndpo nt])
            .requestT  out(200.m ll seconds)
            .retryPol cy(retry(t  outs = 3))
            .bu ld(),
          serv ceNa  = "deferredrpc",
          stats = statsRece ver
        )

      def deferredT etyp e(target: Target): Thr ftT etServ ce = {
        // W n deferr ng back to t  local datacenter, preserve t  f nagle
        // context and dtabs. T  w ll ensure that developer dtabs are honored
        // and that context  s preserved  n eventbus. (eventbus enqueues only
        // happen  n async requests w h n t  sa  datacenter.)
        //
        // Effect vely, t   ans   cons der deferredrpc requests w h n t 
        // sa  datacenter to be part of t  sa  request, but repl cated
        // requests are not.
        val  sLocal: Boolean = target.datacenter == Datacenter.Local

        val deferredThr ftServ ce: Serv ce[Thr ftCl entRequest, Array[Byte]] =
          new DeferredThr ftServ ce(
            deferredRpcCl ent,
            target,
            ser al zeF nagleContexts =  sLocal,
            ser al zeF nagleDtabs =  sLocal
          )

        new T etServ ce nternal$F nagleCl ent(deferredThr ftServ ce)
      }

      val repl cat onCl ent: Thr ftT etServ ce =
        deferredT etyp e(Target(Datacenter.AllOt rs, "t etyp e-repl cat on"))

      // used for read endpo nts repl cat on
      val lowQoSRepl cat onCl ents: Seq[GatedRepl cat onCl ent] = {
        val rampUpGate = Gate.l nearRampUp(T  .now, sett ngs.fork ngRampUp)

        // Gates to avo d send ng repl cated reads from a cluster to  self
        val  nATLA =  f (sett ngs.zone == "atla") Gate.True else Gate.False
        val  nPDXA =  f (sett ngs.zone == "pdxa") Gate.True else Gate.False

        Seq(
          GatedRepl cat onCl ent(
            cl ent = deferredT etyp e(Target(Datacenter.Atla, "t etyp e-lowqos")),
            gate = rampUpGate & dec derGates.repl cateReadsToATLA & ! nATLA
          ),
          GatedRepl cat onCl ent(
            cl ent = deferredT etyp e(Target(Datacenter.Pdxa, "t etyp e-lowqos")),
            gate = rampUpGate & dec derGates.repl cateReadsToPDXA & ! nPDXA
          )
        )
      }

      // used for async operat ons  n t  wr e path
      val asyncT etServ ce: Thr ftT etServ ce =
        deferredT etyp e(Target(Datacenter.Local, "t etyp e"))

      // used to tr gger asyncEraseUserT etsRequest
      val asyncT etDelet onServ ce: Thr ftT etServ ce =
        deferredT etyp e(Target(Datacenter.Local, "t etyp e-ret et-delet on"))

      // used for async retr es
      val asyncRetryT etServ ce: Thr ftT etServ ce =
        deferredT etyp e(Target(Datacenter.Local, "t etyp e-async-retry"))

      val darkTraff cCl ent: Serv ce[Array[Byte], Array[Byte]] = {
        val thr ftServ ce =
          thr ftMuxCl ent(
            "t etyp e.dark",
            propagateDeadl nes = false
          ).w hRequestT  out(100.m ll seconds)
            .newServ ce("/s/t etyp e/proxy")

        val transfor r =
          new F lter[Array[Byte], Array[Byte], Thr ftCl entRequest, Array[Byte]] {
            overr de def apply(
              request: Array[Byte],
              serv ce: Serv ce[Thr ftCl entRequest, Array[Byte]]
            ): Future[Array[Byte]] =
              serv ce(new Thr ftCl entRequest(request, false))
          }

        transfor r andT n thr ftServ ce
      }

      val geoHydrat onCl ent: GeoduckHydrat on. thodPerEndpo nt = {
        val mb = thr ftMux thodBu lder("geoduck_hydrat on", "/s/geo/hydrat on")
          .w hT  outPerRequest(100.m ll s)
          . dempotent(maxExtraLoad = 1.percent)
        Thr ftMux.Cl ent. thodPerEndpo nt(
          mb.serv cePerEndpo nt[GeoduckHydrat on.Serv cePerEndpo nt])
      }

      val geoHydrat onLocate: GeoduckLocate = geoHydrat onCl ent.locate

      val geoReverseGeocoderCl ent: ReverseGeocoder. thodPerEndpo nt = {
        val mb = thr ftMux thodBu lder("geoduck_reversegeocoder", "/s/geo/geoduck_reversegeocoder")
          .w hT  outPerRequest(100.m ll s)
          . dempotent(maxExtraLoad = 1.percent)
        Thr ftMux.Cl ent. thodPerEndpo nt(
          mb.serv cePerEndpo nt[ReverseGeocoder.Serv cePerEndpo nt])
      }

      val geoduckGeohashLocate: GeoduckGeohashLocate = {
        new GeoduckGeohashLocate(
          reverseGeocoderCl ent = geoReverseGeocoderCl ent,
          hydrat onCl ent = geoHydrat onCl ent,
          classScopedStatsRece ver = statsRece ver.scope("geo_geohash_locate"))
      }

      val geoRelevance =
        new Relevance$F nagleCl ent(
          thr ftMuxCl entBu lder(
            "geoduck_relevance",
            "/s/geo/relevance",
            classOf[Relevance. thodPerEndpo nt])
            .requestT  out(100.m ll seconds)
            .retryPol cy(retry(t  outs = 1))
            .bu ld(),
          stats = statsRece ver
        )

      val fanoutServ ceCl ent =
        new FanoutServ ce$F nagleCl ent(
          new DeferredThr ftServ ce(deferredRpcCl ent, Target(Datacenter.Local, "fanoutserv ce")),
          serv ceNa  = "fanoutserv ce",
          stats = statsRece ver
        )

      val l m erServ ce: L m erServ ce = {
        val l m erCl ent =
          new L m erCl entFactory(
            na  = "l m er",
            cl ent d = thr ftCl ent d,
            tracer = tracer,
            statsRece ver = statsRece ver,
            serv ce dent f er = sett ngs.serv ce dent f er,
            opportun st cTlsLevel = Opportun st cTls.Requ red,
            daemon ze = true
          )(eval("/s/l m er/l m er"))

        val l m erBackend = sett ngs.l m erBackendConf g(
          L m erBackend.fromCl ent(l m erCl ent),
          backendContext("l m er")
        )

        L m erServ ce.fromBackend(
          l m erBackend. ncre ntFeature,
          l m erBackend.getFeatureUsage,
          getApp d,
          backendsScope.scope("l m er")
        )
      }

      val passb rdCl ent =
        new Passb rdServ ce$F nagleCl ent(
          thr ftMuxCl entBu lder(
            "passb rd",
            "/s/passb rd/passb rd",
            classOf[Passb rdServ ce. thodPerEndpo nt])
            .requestT  out(100.m ll seconds)
            .retryPol cy(retry(t  outs = 1))
            .bu ld(),
          serv ceNa  = "passb rd",
          stats = statsRece ver
        )

      val esc rb rd: Esc rb rd = {
        val esc rb rdCl ent =
          new T etEnt yAnnotat onServ ce$F nagleCl ent(
            thr ftMuxCl entBu lder(
              "esc rb rd",
              "/s/esc rb rd/annotat onserv ce",
              classOf[T etEnt yAnnotat onScrooge face. thodPerEndpo nt])
              .bu ld()
          )
        sett ngs.esc rb rdConf g(
          Esc rb rd.fromCl ent(esc rb rdCl ent),
          backendContext("esc rb rd")
        )
      }

      val geoScrubEventStore: GeoScrubEventStore = {
        val mhMtlsParams =
           f (sett ngs.serv ce dent f er == EmptyServ ce dent f er) NoMtlsParams
          else
            ManhattanKVCl entMtlsParams(
              serv ce dent f er = sett ngs.serv ce dent f er,
              opportun st cTls = Opportun st cTls.Requ red)

        val mhCl ent =
          new ManhattanKVCl ent(
            app d = "geoduck_scrub_datastore",
            dest = "/s/manhattan/o ga.nat ve-thr ft",
            mtlsParams = mhMtlsParams,
            label = "mh_o ga",
            Seq(Exper  nts.ApertureLoadBalancer)
          )

        GeoScrubEventStore(
          mhCl ent,
          sett ngs.geoScrubEventStoreConf g,
          backendContext("geoScrubEventStore")
        )
      }

      val t etEventsPubl s r: EventBusPubl s r[T etEvent] =
        eventBusPubl s rBu lder
          .streamNa ("t et_events")
          .thr ftStruct(T etEvent)
          .publ shT  out(500.m ll seconds)
          .ser al zeF nagleDtabs(true)
          .bu ld()

      val deleteLocat onDataPubl s r: EventBusPubl s r[DeleteLocat onData] =
        eventBusPubl s rBu lder
          .streamNa ("t etyp e_delete_locat on_data_prod")
          .thr ftStruct(DeleteLocat onData)
          // deleteLocat onData  s relat vely rare, and publ sh ng to
          // eventbus  s all that t  endpo nt does. T   ans that  
          //  s much more l kely that   w ll have to make a connect on,
          // wh ch has much greater latency, and also makes us more
          // tolerant of slow requests, so   choose a long t  out.
          .publ shT  out(2.seconds)
          .bu ld()

      val ret etArch valEventPubl s r: EventBusPubl s r[Ret etArch valEvent] =
        eventBusPubl s rBu lder
          .streamNa ("ret et_arch val_events")
          .thr ftStruct(Ret etArch valEvent)
          .publ shT  out(500.m ll seconds)
          .bu ld()

      val gn pEnr c rator: Gn pEnr c rator = {
        val gn pEnr c rator =
          thr ftMux thodBu lder(
            "enr c rator",
            "/s/datadel very-enr ch nts/enr c rator"
          )
        Gn pEnr c rator.from thod(gn pEnr c rator)
      }

      val stratoserverCl ent: StratoCl ent = Strato.cl ent
        .w hMutualTls(
          serv ce dent f er = sett ngs.serv ce dent f er,
          opportun st cLevel = Opportun st cTls.Requ red)
        .w hLabel("stratoserver")
        .w hRequestT  out(100.m ll seconds)
        .bu ld()

      val conf gBus: Conf gBus =
        Conf gBus(backendsScope.scope("conf g_bus"), sett ngs. nstance d, sett ngs. nstanceCount)

      val callbackPromotedContentLogger: CallbackPromotedContentLogger = {
        val publ s r =
          eventBusPubl s rBu lder
            .streamNa (sett ngs.adsLogg ngCl entTop cNa )
            .thr ftStruct(AdCallbackEvent)
            .publ shT  out(500.m ll seconds)
            .ser al zeF nagleDtabs(true)
            .maxQueuedEvents(1000)
            .kafkaDest("/s/kafka/ads-callback:kafka-tls")
            .bu ld()

        val stats = backendsScope.scope("promoted_content")
        val adsLogg ngCl ent = AdsLogg ngCl ent(publ s r, stats, "T etyp e")
        new CallbackPromotedContentLogger(adsLogg ngCl ent, stats)
      }
    }
  }
}
