package com.tw ter.t etyp e.core

 mport com.tw ter.servo.data.Lens
 mport com.tw ter.st ch.St ch
 mport com.tw ter.t etyp e.thr ftscala.F eldByPath
 mport com.tw ter.t etyp e.thr ftscala.Hydrat onType

/**
 * Encapsulates a value and assoc ated Hydrat onState.  T  class  s  ntended to be used
 * w h `ValueHydrator`, as t  result type for hydrators that d rectly produce updated values,
 *  n contrast w h Ed Hydrator wh ch uses `Ed State` as a result type to produce update funct ons.
 *
 * @tparam A T  type of t  enclosed value, wh ch  s t  result of hydrat on.
 */
f nal case class ValueState[+A](value: A, state: Hydrat onState) {

  /**
   * Appl es a funct on to t  enclosed value and produces a new `ValueState`  nstance.
   */
  def map[B](f: A => B): ValueState[B] =
    ValueState(f(value), state)

  /**
   * Produces a new `ValueState` that conta ns t  value generated by `f`, but w h state that  s
   * t  sum of t  state from t  `ValueState` and t  one produced by `f`.
   */
  def flatMap[B](f: A => ValueState[B]): ValueState[B] = {
    val ValueState(value2, state2) = f(value)
    ValueState(value2, state ++ state2)
  }

  /**
   * Appl es a funct on to t  enclosed state and produces a new `ValueState`  nstance.
   */
  def mapState[T](f: Hydrat onState => Hydrat onState): ValueState[A] =
    ValueState(value, f(state))

  /**
   * Converts a `ValueState[A]` to an `Ed State[B]`, us ng a lens. T  result ng `Ed State`
   * w ll overwr e t  lensed f eld w h t  value from t  `ValueState`.
   */
  def ed [B, A2 >: A](lens: Lens[B, A2]): Ed State[B] =
    Ed State[B](b => ValueState(lens.set(b, value), state))
}

object ValueState {
  val Unmod f edNone: ValueState[None.type] = unmod f ed(None)
  val St chUnmod f edNone: St ch[ValueState[None.type]] = St ch.value(Unmod f edNone)

  val Unmod f edUn : ValueState[Un ] = unmod f ed(())
  val St chUnmod f edUn : St ch[ValueState[Un ]] = St ch.value(Unmod f edUn )

  val Unmod f edN l: ValueState[N l.type] = unmod f ed(N l)
  val St chUnmod f edN l: St ch[ValueState[N l.type]] = St ch.value(Unmod f edN l)

  /**
   * Produces a ValueState  nstance w h t  g ven value and an empty state Hydrat onState.
   */
  def un [A](value: A): ValueState[A] =
    ValueState[A](value, Hydrat onState.empty)

  def unmod f ed[A](value: A): ValueState[A] =
    ValueState(value, Hydrat onState.empty)

  def mod f ed[A](value: A): ValueState[A] =
    ValueState(value, Hydrat onState.mod f ed)

  def mod f ed[A](value: A, hydrat onType: Hydrat onType): ValueState[A] =
    ValueState(value, Hydrat onState.mod f ed(hydrat onType))

  def success[A](value: A, mod f ed: Boolean): ValueState[A] =
    ValueState(value, Hydrat onState(mod f ed))

  def delta[A](prev: A, next: A): ValueState[A] =
    ValueState(next, Hydrat onState.delta(prev, next))

  def part al[A](value: A, f eld: F eldByPath): ValueState[A] =
    ValueState(value, Hydrat onState.part al(f eld))

  def part al[A](value: A, f elds: Set[F eldByPath]): ValueState[A] =
    ValueState(value, Hydrat onState.part al(f elds))

  /**
   * Converts a `Seq` of `ValueState[A]` to a `ValueState` of `Seq[A]`.
   */
  def sequence[A](seq: Seq[ValueState[A]]): ValueState[Seq[A]] = {
    ValueState(
      value = seq.map(_.value),
      state = Hydrat onState.jo n(seq.map(_.state): _*)
    )
  }

  def jo n[A, B](va: ValueState[A], vb: ValueState[B]): ValueState[(A, B)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state
      )

    val value = (
      va.value,
      vb.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C]
  ): ValueState[(A, B, C)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D]
  ): ValueState[(A, B, C, D)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E]
  ): ValueState[(A, B, C, D, E)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F]
  ): ValueState[(A, B, C, D, E, F)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F, G](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F],
    vg: ValueState[G]
  ): ValueState[(A, B, C, D, E, F, G)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state,
        vg.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value,
      vg.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F, G, H](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F],
    vg: ValueState[G],
    vh: ValueState[H]
  ): ValueState[(A, B, C, D, E, F, G, H)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state,
        vg.state,
        vh.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value,
      vg.value,
      vh.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F, G, H,  ](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F],
    vg: ValueState[G],
    vh: ValueState[H],
    v : ValueState[ ]
  ): ValueState[(A, B, C, D, E, F, G, H,  )] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state,
        vg.state,
        vh.state,
        v .state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value,
      vg.value,
      vh.value,
      v .value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F, G, H,  , J](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F],
    vg: ValueState[G],
    vh: ValueState[H],
    v : ValueState[ ],
    vj: ValueState[J]
  ): ValueState[(A, B, C, D, E, F, G, H,  , J)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state,
        vg.state,
        vh.state,
        v .state,
        vj.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value,
      vg.value,
      vh.value,
      v .value,
      vj.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F, G, H,  , J, K](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F],
    vg: ValueState[G],
    vh: ValueState[H],
    v : ValueState[ ],
    vj: ValueState[J],
    vk: ValueState[K]
  ): ValueState[(A, B, C, D, E, F, G, H,  , J, K)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state,
        vg.state,
        vh.state,
        v .state,
        vj.state,
        vk.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value,
      vg.value,
      vh.value,
      v .value,
      vj.value,
      vk.value
    )

    ValueState(value, state)
  }

  def jo n[A, B, C, D, E, F, G, H,  , J, K, L](
    va: ValueState[A],
    vb: ValueState[B],
    vc: ValueState[C],
    vd: ValueState[D],
    ve: ValueState[E],
    vf: ValueState[F],
    vg: ValueState[G],
    vh: ValueState[H],
    v : ValueState[ ],
    vj: ValueState[J],
    vk: ValueState[K],
    vl: ValueState[L]
  ): ValueState[(A, B, C, D, E, F, G, H,  , J, K, L)] = {
    val state =
      Hydrat onState.jo n(
        va.state,
        vb.state,
        vc.state,
        vd.state,
        ve.state,
        vf.state,
        vg.state,
        vh.state,
        v .state,
        vj.state,
        vk.state,
        vl.state
      )

    val value = (
      va.value,
      vb.value,
      vc.value,
      vd.value,
      ve.value,
      vf.value,
      vg.value,
      vh.value,
      v .value,
      vj.value,
      vk.value,
      vl.value
    )

    ValueState(value, state)
  }
}
