package com.tw ter.graph.batch.job.t epcred

 mport com.tw ter.data.proto.Flock
 mport com.tw ter.scald ng._
 mport com.tw ter.pluck.s ce._
 mport com.tw ter.pluck.s ce.comb ned_user_s ce.MostRecentComb nedUserSnapshotS ce
 mport com.tw ter.scald ng_ nternal.dalv2.DAL
 mport com.tw ter.serv ce. nteract ons. nteract onGraph
 mport graphstore.common.FlockFollowsJavaDataset
 mport java.ut l.T  Zone

/**
 * Prepare t  graph data for page rank calculat on. Also generate t   n  al
 * pagerank as t  start ng po nt. Afterwards, start   ghtedPageRank job.
 *
 * E  r read a tsv f le for test ng or read t  follow ng to bu ld t  graph
 *   flock edges Flock.Edge
 *   real graph  nput for   ghts  nteract onGraph.Edge
 *
 * Opt ons:
 * --pwd: work ng d rectory, w ll generate t  follow ng f les t re
 *        numnodes: total number of nodes
 *        nodes: nodes f le <'src_ d, 'dst_ ds, '  ghts, 'mass_pr or>
 *        pagerank: t  page rank f le
 * --user_mass: user mass tsv f le, generated by twadoop user_mass job
 * Opt onal argu nts:
 * -- nput: use t  g ven tsv f le  nstead of flock and real graph
 * --  ghted: do   ghted pagerank, default false
 * --flock_edges_only: restr ct graph to flock edges, default true
 * -- nput_pagerank: cont nue pagerank from t 
 *
 * Plus t  follow ng opt ons for   ghtedPageRank and ExtractT epcred:
 * --output_pagerank: w re to put pagerank f le
 * --output_t epcred: w re to put t epcred f le
 * Opt onal:
 * --max erat ons: how many  erat ons to run.  Default  s 20
 * --jumpprob: probab l y of a random jump, default  s 0.1
 * --threshold: total d fference before f n sh ng early, default 0.001
 * --post_adjust: w t r to do post adjust, default true
 */
class PreparePageRankData(args: Args) extends Job(args) {
   mpl c  val t  Zone: T  Zone = DateOps.UTC
  val PWD = args("pwd")
  val WE GHTED = args.getOrElse("  ghted", "false").toBoolean
  val FLOCK_EDGES_ONLY = args.getOrElse("flock_edges_only", "true").toBoolean

  val ROW_TYPE_1 = 1
  val ROW_TYPE_2 = 2

  // graph data and user mass
  val userMass = getUserMass
  val nodesW hPr or = getGraphData(userMass)
  val numNodes = nodesW hPr or.groupAll { _.s ze }
  numNodes.wr e(Tsv(PWD + "/numnodes"))
  dumpNodes(nodesW hPr or, PWD + "/nodes");

  //  n  al pagerank to start computat on
  generate n  alPagerank(nodesW hPr or)

  // cont nue w h t  calculat on
  overr de def next = {
    So (new   ghtedPageRank(args))
  }

  /**
   * read flock edges
   */
  def getFlockEdges = {
    DAL
      .readMostRecentSnapshotNoOlderThan(FlockFollowsJavaDataset, Days(7))
      .toTypedS ce
      .flatMapTo('src_ d, 'dst_ d) { edge: Flock.Edge =>
         f (edge.getState d() == Flock.State.Pos  ve.getNumber()) {
          So ((edge.getS ce d(), edge.getDest nat on d()))
        } else {
          None
        }
      }
  }

  /**
   * read real graph edges w h   ghts
   */
  def getRealGraphEdges = {
    RealGraphEdgeS ce()
      .flatMapTo('src_ d, 'dst_ d, '  ght) { edge:  nteract onGraph.Edge =>
         f (edge.getS ce d() != edge.getDest nat on d()) {
          val src d = edge.getS ce d()
          val dst d = edge.getDest nat on d()
          val   ght = edge.get  ght().toFloat
          So ((src d, dst d,   ght))
        } else {
          None
        }
      }
  }

  /**
   * comb ne real graph and flock.  f flock_edges_only  s true, only take t 
   * flock edges; ot rw se edges are e  r from flock or from real graph.
   * edges   ghts default to be 1, overwr ten by   ghts from real graph
   */
  def getFlockRealGraphEdges = {
    val flock = getFlockEdges

     f (WE GHTED) {
      val flockW h  ght = flock
        .map(() -> ('  ght, 'rowtype)) { (u: Un ) =>
          (1.0f, ROW_TYPE_1)
        }

      val realGraph = getRealGraphEdges
        .map(() -> 'rowtype) { (u: Un ) =>
          (ROW_TYPE_2)
        }

      val comb ned = (flockW h  ght ++ realGraph)
        .groupBy('src_ d, 'dst_ d) {
          _.m n('rowtype)
            .max('  ght) // take wh c ver  s b gger
        }

       f (FLOCK_EDGES_ONLY) {
        comb ned.f lter('rowtype) { (rowtype:  nt) =>
          rowtype == ROW_TYPE_1
        }
      } else {
        comb ned
      }
    } else {
      flock.map(() -> ('  ght)) { (u: Un ) =>
        1.0f
      }
    }.project('src_ d, 'dst_ d, '  ght)
  }

  def getCsvEdges(f leNa : Str ng) = {
    Tsv(f leNa ).read
      .mapTo((0, 1, 2) -> ('src_ d, 'dst_ d, '  ght)) {  nput: (Long, Long, Float) =>
         nput
      }
  }

  /*
   * Compute user mass based on comb ned user
   */
  def getUserMass =
    TypedP pe
      .from(MostRecentComb nedUserSnapshotS ce)
      .flatMap { user =>
        UserMass.getUserMass(user)
      }
      .map { userMass nfo =>
        (userMass nfo.user d, userMass nfo.mass)
      }
      .toP pe[(Long, Double)]('src_ d_ nput, 'mass_pr or)
      .normal ze('mass_pr or)

  /**
   * Read e  r flock/real_graph or a g ven tsv f le
   * group by t  s ce  d, and output node data structure
   *  rge w h t  user_mass.
   * return <'src_ d, 'dst_ ds, '  ghts, 'mass_pr or>
   *
   * make sure src_ d  s t  sa  set as  n user_mass, and dst_ ds
   * are subset of user_mass. eg flock has edges l ke 1->2,
   * w re both users 1 and 2 do not ex st anymore
   */
  def getGraphData(userMass: R chP pe) = {
    val edges: R chP pe = args.opt onal(" nput") match {
      case None => getFlockRealGraphEdges
      case So ( nput) => getCsvEdges( nput)
    }

    // remove edges w re dst_ d  s not  n userMass
    val f lterByDst = userMass
      .jo nW hLarger('src_ d_ nput -> 'dst_ d, edges)
      .d scard('src_ d_ nput, 'mass_pr or)

    // aggreate by t  s ce  d
    val nodes = f lterByDst
      .groupBy('src_ d) {
        _.mapReduceMap(('dst_ d, '  ght) -> ('dst_ ds, '  ghts)) /* map1 */ { a: (Long, Float) =>
          (Vector(a._1),  f (WE GHTED) Vector(a._2) else Vector())
        } /* reduce */ { (a: (Vector[Long], Vector[Float]), b: (Vector[Long], Vector[Float])) =>
          {
            (a._1 ++ b._1, a._2 ++ b._2)
          }
        } /* map2 */ { a: (Vector[Long], Vector[Float]) =>
          a
        }
      }
      .mapTo(
        ('src_ d, 'dst_ ds, '  ghts) -> ('src_ d, 'dst_ ds, '  ghts, 'mass_pr or, 'rowtype)) {
         nput: (Long, Vector[Long], Vector[Float]) =>
          {
            ( nput._1,  nput._2.toArray,  nput._3.toArray, 0.0, ROW_TYPE_1)
          }
      }

    // get to t  sa  sc ma
    val userMassNodes = userMass
      .mapTo(('src_ d_ nput, 'mass_pr or) -> ('src_ d, 'dst_ ds, '  ghts, 'mass_pr or, 'rowtype)) {
         nput: (Long, Double) =>
          {
            ( nput._1, Array[Long](), Array[Float](),  nput._2, ROW_TYPE_2)
          }
      }

    // make src_ d t  sa  set as  n userMass
    (nodes ++ userMassNodes)
      .groupBy('src_ d) {
        _.sortBy('rowtype)
          . ad('dst_ ds, '  ghts)
          .last('mass_pr or, 'rowtype)
      }
      .f lter('rowtype) {  nput:  nt =>
         nput == ROW_TYPE_2
      }
  }

  /**
   * generate t  graph data output
   */
  def dumpNodes(nodes: R chP pe, f leNa : Str ng) = {
    mode match {
      case Hdfs(_, conf) => nodes.wr e(SequenceF le(f leNa ))
      case _ =>
        nodes
          .mapTo((0, 1, 2, 3) -> (0, 1, 2, 3)) {  nput: (Long, Array[Long], Array[Float], Double) =>
            ( nput._1,  nput._2.mkStr ng(","),  nput._3.mkStr ng(","),  nput._4)
          }
          .wr e(Tsv(f leNa ))
    }
  }

  /*
   * output pr or mass or copy t  g ven mass f le ( rge, normal ze)
   * to be used as t  start ng po nt
   */
  def generate n  alPagerank(nodes: R chP pe) = {
    val pr or = nodes
      .project('src_ d, 'mass_pr or)

    val comb ned = args.opt onal(" nput_pagerank") match {
      case None => pr or
      case So (f leNa ) => {
        val mass nput = Tsv(f leNa ).read
          .mapTo((0, 1) -> ('src_ d, 'mass_pr or, 'rowtype)) {  nput: (Long, Double) =>
            ( nput._1,  nput._2, ROW_TYPE_2)
          }

        val pr orRow = pr or
          .map(() -> ('rowtype)) { (u: Un ) =>
            ROW_TYPE_1
          }

        (pr orRow ++ mass nput)
          .groupBy('src_ d) {
            _.sortBy('rowtype)
              .last('mass_pr or)
              . ad('rowtype)
          }
          // throw away extra nodes from  nput f le
          .f lter('rowtype) { (rowtype:  nt) =>
            rowtype == ROW_TYPE_1
          }
          .d scard('rowtype)
          .normal ze('mass_pr or)
      }
    }

    comb ned.wr e(Tsv(PWD + "/pagerank_0"))
  }
}
