package com.tw ter.s mclusters_v2.scald ng.evaluat on

 mport com.tw ter.core_workflows.user_model.thr ftscala.CondensedUserState
 mport com.tw ter.core_workflows.user_model.thr ftscala.UserState
 mport com.tw ter.pluck.s ce.core_workflows.user_model.CondensedUserStateScalaDataset
 mport com.tw ter.scald ng._
 mport com.tw ter.scald ng.s ce.TypedText
 mport com.tw ter.scald ng_ nternal.dalv2.DAL
 mport com.tw ter.scald ng_ nternal.job.Tw terExecut onApp
 mport com.tw ter.s mclusters_v2.thr ftscala.Cand dateT ets
 mport com.tw ter.s mclusters_v2.thr ftscala.ReferenceT ets
 mport scala.ut l.Random

/**
 *  lper funct ons to prov de user samples by sampl ng across user states.
 */
object UserStateUserSampler {
  def getSampleUsersByUserState(
    userStateS ce: TypedP pe[CondensedUserState],
    val dStates: Seq[UserState],
    samplePercentage: Double
  ): TypedP pe[(UserState, Long)] = {
    assert(samplePercentage >= 0 && samplePercentage <= 1)
    val val dStateSet = val dStates.toSet

    userStateS ce
      .collect {
        case data  f data.userState. sDef ned && val dStateSet.conta ns(data.userState.get) =>
          (data.userState.get, data.u d)
      }
      .f lter(_ => Random.nextDouble() <= samplePercentage)
      .forceToD sk
  }

  /**
   * G ven a l st of str ng correspond ng to user states, convert t m to t  UserState type.
   *  f t   nput  s empty, default to return all ava lable user states
   */
  def parseUserStates(strStates: Seq[Str ng]): Seq[UserState] = {
     f (strStates. sEmpty) {
      UserState.l st
    } else {
      strStates.map { str =>
        UserState
          .valueOf(str).getOrElse(
            throw new  llegalArgu ntExcept on(
              s" nput user_states $str  s  nval d. Val d states are: " + UserState.l st
            )
          )
      }
    }
  }
}

/**
 * A var at on of t  evaluat on base w re target users are sampled by user states.
 * For each user state of  nterest (e.x. HEAVY_TWEETER),   run a separate evaluat on call, and
 * output t  evaluat on results per user state. T   s  lpful w n   want to hor zontally
 * compare how users  n d fferent user states respond to t  cand date t ets.
 */
tra  UserStateBasedEvaluat onExecut onBase
    extends Cand dateEvaluat onBase
    w h Tw terExecut onApp {

  def referenceT ets: TypedP pe[ReferenceT ets]
  def cand dateT ets: TypedP pe[Cand dateT ets]

  overr de def job: Execut on[Un ] = {
    Execut on.w h d {  mpl c  un que d =>
      Execut on.w hArgs { args =>
         mpl c  val dateRange: DateRange =
          DateRange.parse(args.l st("date"))(DateOps.UTC, DateParser.default)

        val outputRootD r = args("outputD r")
        val userStates: Seq[UserState] =
          UserStateUserSampler.parseUserStates(args.l st("user_states"))
        val sampleRate = args.double("sample_rate")

        // For each user state   are  nterested  n, run separate execut ons and wr e
        // t  output  nto  nd v dual sub d rector es
        val userStateS ce = DAL.read(CondensedUserStateScalaDataset).toTypedP pe
        val user dsByState =
          UserStateUserSampler.getSampleUsersByUserState(userStateS ce, userStates, sampleRate)
        val execut onsPerUserState = userStates.map { userState =>
          val sampleUsers = user dsByState.collect { case data  f data._1 == userState => data._2 }
          val outputPath = outputRootD r + "/" + userState + "/"

          super
            .runSampledEvaluat on(sampleUsers, referenceT ets, cand dateT ets)
            .wr eExecut on(TypedText.csv(outputPath))
        }
        // Run evaluat on for each user state  n parallel
        Execut on.sequence(execut onsPerUserState).un 
      }
    }
  }
}

/**
 * A bas c flow for evaluat ng t  qual y of a set of cand date t ets, typ cally generated by an
 * algor hm (ex. S mClusters), by compar ng  s engage nt rates aga nst a set of reference t ets
 * T  job goes through t  follow ng steps:
 * 1. Generate a group of target users on wh ch    asure t et engage nts
 * 2. Collect t ets  mpressed by t se users and t  r engage nts on t ets from a labeled
 * t et s ce (ex. Ho  T  l ne engage nt data), and form a reference set
 * 3. For each cand date t et, collect t  engage nt rates from t  reference set
 * 4. Run evaluat on calculat ons (ex. percentage of  ntersect on, engage nt rate, etc)
 *
 * Each sub class  s expected to prov de 3 sets of data s ces, wh ch are t  sample users,
 * cand date t et s ces, and reference t et s ces.
 */
tra  Cand dateEvaluat onBase {
  pr vate def getSampledReferenceT ets(
    referenceT etEngage nts: TypedP pe[ReferenceT ets],
    sampleUsers: TypedP pe[Long]
  ): TypedP pe[ReferenceT ets] = {
    referenceT etEngage nts
      .groupBy(_.targetUser d)
      .jo n(sampleUsers.asKeys)
      .map { case (targetUser d, (referenceEngage nts, _)) => referenceEngage nts }
  }

  pr vate def getSampledCand dateT ets(
    cand dateT ets: TypedP pe[Cand dateT ets],
    sampleUsers: TypedP pe[Long]
  ): TypedP pe[Cand dateT ets] = {
    cand dateT ets
      .groupBy(_.targetUser d)
      .jo n(sampleUsers.asKeys)
      .map { case (_, (t ets, _)) => t ets }
  }

  /**
   * Evaluat on funct on, should be overr dden by  mple nt ng sub classes to su   nd v dual
   * object ves, such as l ke engage nt rates, CRT, etc.
   * @param sampledReference
   * @param sampledCand date
   */
  def evaluateResults(
    sampledReference: TypedP pe[ReferenceT ets],
    sampledCand date: TypedP pe[Cand dateT ets]
  ): TypedP pe[Str ng]

  /**
   * G ven a l st of target users, t  reference t et set, and t  cand date t et set,
   * calculate t  engage nt rates on t  reference set and t  cand date set by t se users.
   * T  evaluat on result should be converted  nto an  em zed format
   * t se users.
   * @param referenceT ets
   * @param cand dateT ets
   * @return
   */
  def runSampledEvaluat on(
    targetUserSamples: TypedP pe[Long],
    referenceT ets: TypedP pe[ReferenceT ets],
    cand dateT ets: TypedP pe[Cand dateT ets]
  ): TypedP pe[Str ng] = {
    val sampledCand date = getSampledCand dateT ets(cand dateT ets, targetUserSamples)
    val referencePerUser = getSampledReferenceT ets(referenceT ets, targetUserSamples)

    evaluateResults(referencePerUser, sampledCand date)
  }
}
